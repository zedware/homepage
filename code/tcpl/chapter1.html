<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Chapter 1 - A Tutorial Introduction</title>
<style type="text/css">
<!--
.STYLE1 {font-weight: bold}
.STYLE2 {color: #FF0000}
-->
</style>
</head>
<body>
<hr>
<p align="center">
<a href="intro.html">Back to Introduction</a>&nbsp;--&nbsp;
<a href="index.html">Index</a>&nbsp;--&nbsp;
<a href="chapter2.html">Chapter 2</a>
<p>
<hr>

<h1>Chapter 1 - A Tutorial Introduction</h1>
<strong>Let us begin with a quick introduction in C. Our aim is to show the
essential elements of the language in real programs, but without getting
bogged down in details, rules, and exceptions. At this point, we are not
trying to be complete or even precise (save that the examples are meant to be
correct). We want to get you as quickly as possible to the point where you
can write useful programs, and to do that we have to concentrate on the
basics: variables and constants, arithmetic, control flow, functions, and the
rudiments of input and output. We are intentionally leaving out of this
chapter features of C that are important for writing bigger programs. These
include pointers, structures, most of C's rich set of operators, several
control-flow statements, and the standard library.</strong>
<p>
This approach and its drawbacks. Most notable is that the complete story on
any particular feature is not found here, and the tutorial, by being brief,
may also be misleading. And because the examples do not use the full power of
C, they are not as concise and elegant as they might be. We have tried to
minimize these effects, but be warned. Another drawback is that later
chapters will necessarily repeat some of this chapter. We hope that the
repetition will help you more than it annoys.
<p>
<strong>In any case, experienced programmers should be able to extrapolate(推断) from the
material in this chapter to their own programming needs. Beginners should
supplement it by writing small, similar programs of their own. Both groups
can use it as a framework on which to hang the more detailed descriptions
that begin in </strong><a href="chapter2.html">Chapter 2</a>.
<h2><a name="s1.1">1.1 Getting Started</a></h2>
<b>The only way to learn a new programming language is by writing programs in
it.</b> The first program to write is the same for all languages:<br>
&nbsp;<em>Print the words</em><br>
&nbsp;<tt>hello, world</tt>
<p>
This is a big hurdle; to leap over it you have to be able to create the
program text somewhere, compile it successfully, load it, run it, and find
out where your output went. With these mechanical details mastered,
everything else is comparatively easy.
<p class="STYLE1">
In C, the program to print ``<tt>hello, world</tt>'' is
<pre><strong>   #include &lt;stdio.h&gt;

   int main(void)
   {
       printf("hello, world\n");
       return 0;
   }
</strong></pre>
Just how to run this program depends on the system you are using. As a
specific example, on the UNIX operating system you must create the program
in a file whose name ends in ``<tt>.c</tt>'', such as <tt>hello.c</tt>, then
compile it with the command
<pre><strong>
   $ cc hello.c

or

   $ gcc hello.c
</strong>
<strong>or 

   $ &lt;whatever C&gt; hello.c</strong>
</pre>
If you haven't botched anything, such as omitting a character or misspelling
something, the compilation will proceed silently, and make an executable file
called <tt>a.out</tt>. If you run <tt>a.out</tt> by typing the command
<pre><strong>
   $ ./a.out
</strong></pre>
it will print
<pre>
   hello, world
</pre>
On other systems, the rules will be different; check with a local expert. 
On Windows, assume we use Microsoft Visual C++.
<pre><strong>
   C:\> cl hello.c
</strong></pre>
<pre><strong>   C:\> hello
</strong></pre>
it will print the same words.<strong> As a professional programmer, we should master the command lines.
</strong>
<p>
Now, for some explanations about the program itself. A C program, whatever
its size, consists of <em>functions</em> and <em>variables</em>. A function
contains <em>statements</em> that specify the computing operations to be done,
and variables store values used during the computation. C functions are like
the subroutines and functions in Fortran or the procedures and functions of
Pascal. Our example is a function named <tt>main</tt>. Normally you are at
liberty to give functions whatever names you like, but ``<tt>main</tt>'' is
special - your program begins executing at the beginning of main. This means
that every program must have a <tt>main</tt> somewhere.
<pre><strong>    int main(void)<br>
    int main(int argc, char *argv[]);<br>
    See also: </strong><a href=http://cpp.ga-la.com/html/3/3/0510/5.htm>void main()?</a> <strong>(是不是有点像：回字有四种写法？)</strong></pre>
<p>
<strong>
The return code of main() and the return code of a process. Under Linux:</strong>
<p><strong> &nbsp;&nbsp;&nbsp; $ ./a.out
  
</strong>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;Print out the return code of the latest process ./a.out
</strong>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;$ echo $?
  
</strong>
<p><strong>Under Windows:
  
</strong>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;C:\&gt; a.exe
  
    <br>
&nbsp;&nbsp;&nbsp;&nbsp;C:\&gt; echo %errorlevel%</strong>
<p><strong> The return code of main is useful. Here is an example:</strong>
<p><strong>&nbsp;&nbsp;&nbsp; $ cat Makefile</strong>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp; all: test
  
</strong>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test:
  ./a.out </strong>
<p>
<strong>
If a.out returns zero, then ``make test'' will run quietly without no errors at all. If a.out returns a value other than zero, ``make test'' will output error messages.</strong>
<p>
<tt>main</tt> will usually call other functions to help perform its job, some
that you wrote, and others from libraries that are provided for you. The
first line of the program,
<pre><strong>   #include &lt;stdio.h&gt;</strong></pre>
tells the compiler to include information about the standard input/output
library; the line appears at the beginning of many C source files. The
standard library is described in <a href="chapter7.html">Chapter 7</a> and
<a href="appb.html">Appendix B</a>.
<p>
One method of communicating data between functions is for the calling
function to provide a list of values, called <em>arguments</em>, to the function
it calls. The parentheses after the function name surround the argument list.
In this example, <tt>main</tt> is defined to be a function that expects no
arguments, which is indicated by the empty list <tt>( )</tt>.
<hr>
<pre>
#include &lt;stdio.h&gt;                 <em>include information about standard library</em><br>
int main(void)                     <em>define a function called main</em>
                                   <em>that received no argument values</em>
{                                  <em>statements of main are enclosed in braces</em>
    printf("hello, world\n");      <em>main calls library function printf</em>
    return 0;                      <em>to print this sequence of characters</em>
}                                  \n <em>represents the newline character</em>
</pre>
<p align="center">
<strong>The first C program</strong>
<hr>
<p>
The statements of a function are enclosed in braces <tt>{ }</tt>.
The function <tt>main</tt> contains only two statements,
<pre>
   printf("hello, world\n");
   return 0;
</pre>
A function is called by naming it, followed by a parenthesized list of
arguments, so this calls the function <tt>printf</tt> with the argument
<tt>"hello, world\n"</tt>. <tt>printf</tt> is a library function that prints
output, in this case the string of characters between the quotes.
<p>
A sequence of characters in double quotes, like <tt>"hello, world\n"</tt>, is
called a <em>character string</em> or <em>string constant</em>. For the
moment our only use of character strings will be as arguments for
<tt>printf</tt> and other functions.
<p>
The sequence <tt>\n</tt> in the string is C notation for the <em>newline
character</em>, which when printed advances the output to the left margin on
the next line. If you leave out the <tt>\n</tt> (a worthwhile experiment),
you will find that there is no line advance after the output is printed. You
must use <tt>\n</tt> to include a newline character in the <tt>printf</tt>
argument; if you try something like
<pre>
   printf("hello, world
   ");
</pre>
the C compiler will produce an error message.
<p>
<tt>printf</tt> never supplies a newline character automatically, so several
calls may be used to build up an output line in stages. Our first program
could just as well have been written
<pre>
   #include &lt;stdio.h&gt;

   int main(void)
   {
       printf("hello, ");
       printf("world");
       printf("\n");
       return 0;
   }
</pre>
to produce identical output.
<p>
Notice that <tt>\n</tt> represents only a single character. An <em>escape
sequence</em> like <tt>\n</tt> provides a general and extensible mechanism for
representing hard-to-type or invisible characters. Among the others that C
provides are <tt>\t</tt> for tab, <tt>\b</tt> for backspace, <tt>\"</tt> for
the double quote and <tt>\\</tt> for the backslash itself. There is a complete
list in <a href="chapter2.html#s2.3">Section 2.3</a>.
<p>
<strong>Exercise 1-1.</strong> Run the ``<tt>hello, world</tt>'' program on
your system. Experiment with leaving out parts of the program, to see what
error messages you get.
<p>
<strong>Exercise 1-2.</strong> Experiment to find out what happens when
<tt>prints</tt>'s argument string contains <tt>\</tt><em>c</em>, where <em>c</em> is
some character not listed above.
<h2><a name="s1.2">1.2 Variables and Arithmetic Expressions</a></h2>
<strong>The next program uses the formula <sup>o</sup>C = (5 / 9)(<sup>o</sup>F - 32) to
print the following table of Fahrenheit temperatures and their centigrade or
Celsius equivalents:</strong>
<pre>
   1    -17
   20   -6
   40   4
   60   15
   80   26
   100  37
   120  48
   140  60
   160  71
   180  82
   200  93
   220  104
   240  115
   260  126
   280  137
   300  148
</pre>
<strong>The program itself still consists of the definition of a single function
named <tt>main</tt>. It is longer than the one that printed ``<tt>hello, world</tt>'',
but not complicated. It introduces several new ideas, including comments,
declarations, variables, arithmetic expressions, loops, and formatted output.</strong>
<pre><strong>
   #include &lt;stdio.h&gt;

   /* Print Fahrenheit-Celsius table
    * for fahr = 0, 20, ..., 300
    */
   int main(void)
   {
     int fahr, celsius;
     int lower, upper, step;

     lower = 0;      /* lower limit of temperature scale */
     upper = 300;    /* upper limit */
     step = 20;      /* step size */

     fahr = lower;
     while (fahr &lt;= upper) {
         celsius = 5 * (fahr - 32) / 9;
         printf("%d\t%d\n", fahr, celsius);
         fahr += step;
     }
     
     return 0;
   }
</strong></pre>
The three lines
<pre>
  /* Print Fahrenheit-Celsius table
   * for fahr = 0, 20, ..., 300
   */
</pre>
are a <em>comment</em>, which in this case explains briefly what the program
does. <strong>Any characters between <tt>/*</tt> and <tt>*/</tt> are ignored by the
compiler; they may be used freely to make a program easier to understand.
Comments may appear anywhere where a blank, tab or newline can. C does not
allow nested comments like: /* /* */ */. Although some compilers support it,
please avoid using it in practice. If you like, you can use </strong>
<pre><strong>    #if 0
    
    #endif /* 0 */</strong></pre>
<strong>instead to comment out a block of lines. C does not support single line comments,
either(although some new standards or compilers do support it). Avoid using it
in our source code, too.</strong>
<pre><strong>    // avoid using this kind of comments in C programs.</strong></pre>
<p>In C, all variables must be declared before they are used, usually at the
beginning of the function before any executable statements. A
<em>declaration</em> announces the properties of variables; it consists of a
name and a list of variables, such as
<pre>
    int fahr, celsius;
    int lower, upper, step;
</pre>
The type <tt>int</tt> means that the variables listed are integers; by contrast
with <tt>float</tt>, which means floating point, i.e., numbers that may have a
fractional part. The range of both <tt>int</tt> and <tt>float</tt> depends on the
machine you are using; 16-bits <tt>int</tt>s, which lie between -32768 and
+32767, are common, as are 32-bit <tt>int</tt>s. A <tt>float</tt> number is
typically a 32-bit quantity, with at least six significant digits and
magnitude generally between about 10<sup>-38</sup> and 10<sup>38</sup>.
<p>
C provides several other data types besides <tt>int</tt> and <tt>float</tt>,
including:
<table align="center" border=1>
<tr>
<td><strong>&nbsp;<tt>char</tt>&nbsp;  </strong></td><td><strong>&nbsp;character - a single byte</strong></td>
<tr>
<td><strong>&nbsp;<tt>short</tt>&nbsp; </strong></td><td><strong>&nbsp;short integer</strong></td>
<tr>
<td><strong>&nbsp;<tt>long</tt>&nbsp;  </strong></td><td><strong>&nbsp;long integer</strong></td>
<tr>
<td><strong>&nbsp;<tt>double</tt>&nbsp;</strong></td><td><strong>&nbsp;double-precision floating point&nbsp;</strong></td>
</table>
<p><strong>
The size of these objects is also machine-dependent. There are also
  <em>arrays</em>, <em>structures</em> and <em>unions</em> of these basic types,
  <em>pointers</em> to them, and <em>functions</em> that return them, all of
which we will meet in due course.
</strong>
<p>
Computation in the temperature conversion program begins with the
<em>assignment statements</em>
<pre>
    lower = 0;
    upper = 300;
    step = 20;
</pre>
which set the variables to their initial values. Individual statements are
terminated by semicolons.
<p>
Each line of the table is computed the same way, so  we use a loop that
repeats once per output line; this is the purpose of the <tt>while</tt> loop
<pre>
    while (fahr &lt;= upper) {
       ...
    }
</pre>
The <tt>while</tt> loop operates as follows: The condition in parentheses is
tested. If it is true (<tt>fahr</tt> is less than or equal to <tt>upper</tt>), the
body of the loop (the three statements enclosed in braces) is executed. Then
the condition is re-tested, and if true, the body is executed again. When the
test becomes false (<tt>fahr</tt> exceeds <tt>upper</tt>) the loop ends, and
execution continues at the statement that follows the loop. There are no
further statements in this program, so it terminates.
<p>
The body of a <tt>while</tt> can be one or more statements enclosed in braces,
as in the temperature converter, or a single statement without braces, as in
<pre>
   while (i &lt; j)
       i *= 2;
</pre>
In either case, we will always indent the statements controlled by the <tt>
while</tt> by one tab stop (which we have shown as four spaces) so you can see at
a glance which statements are inside the loop. The indentation emphasizes the
logical structure of the program. Although C compilers do not care about how
a program looks, proper indentation and spacing are critical in making
programs easy for people to read. We recommend writing only one statement per
line, and using blanks around operators to clarify grouping. The position of
braces is less important, although people hold passionate beliefs. We have
chosen one of several popular styles. Pick a style that suits you, then use
it consistently.
<p>
Most of the work gets done in the body of the loop. The Celsius temperature
is computed and assigned to the variable <tt>celsius</tt> by the statement
<pre>
        celsius = 5 * (fahr - 32) / 9;
</pre>
The reason for multiplying by 5 and dividing by 9 instead of just multiplying
by <tt>5/9</tt> is that in C, as in many other languages, integer division
<em> truncates</em>: any fractional part is discarded. Since <tt>5</tt> and
<tt>9</tt> are integers. <tt>5/9</tt> would be truncated to zero and so all
the Celsius temperatures would be reported as zero.
<p><strong>
This example also shows a bit more of how <tt>printf</tt> works. <tt>printf</tt>
is a general-purpose output formatting function, which we will describe in
detail in <a href="chapter7.html">Chapter 7</a>. Its first argument is a string
of characters to be printed, with each <tt>%</tt> indicating where one of the
other (second, third, ...) arguments is to be substituted, and in what form
it is to be printed. For instance, <tt>%d</tt> specifies an integer argument,
so the statement
</strong>
<pre>
        printf("%d\t%d\n", fahr, celsius);
</pre>
causes the values of the two integers <tt>fahr</tt> and <tt>celsius</tt> to be
printed, with a tab (<tt>\t</tt>) between them.
<p>
Each <tt>%</tt> construction in the first argument of <tt>printf</tt> is paired
with the corresponding second argument, third argument, etc.; they must match
up properly by number and type, or you will get wrong answers.
<p><strong>
By the way, <tt>printf</tt> is not part of the C language; there is no input or
output defined in C itself. <tt>printf</tt> is just a useful function from the
standard library of functions that are normally accessible to C programs. The
behaviour of <tt>printf</tt> is defined in the ANSI standard, however, so its
properties should be the same with any compiler and library that conforms to
the standard.
</strong>
<p>
In order to concentrate on C itself, we don't talk much about input and
output until <a href="chapter7.html">chapter 7</a>. In particular, we will
defer formatted input until then. If you have to input numbers, read the
discussion of the function <tt>scanf</tt> in
<a href="chapter7.html#s7.4">Section 7.4</a>. <tt>scanf</tt> is like
<tt>printf</tt>, except that it reads input instead of writing output.
<p>
There are a couple of problems with the temperature conversion program. The
simpler one is that the output isn't very pretty because the numbers are not
right-justified. That's easy to fix; if we augment each <tt>%d</tt> in the
<tt>printf</tt> statement with a width, the numbers printed will be right-justified
in their fields. For instance, we might say
<pre>
   printf("%3d %6d\n", fahr, celsius);
</pre>
to print the first number of each line in a field three digits wide, and the
second in a field six digits wide, like this:
<pre>
     0     -17
    20      -6
    40       4
    60      15
    80      26
   100      37
   ...
</pre>
<strong>The more serious problem is that because we have used integer arithmetic, the
Celsius temperatures are not very accurate; for instance, 0<sup>o</sup>F is
actually about -17.8<sup>o</sup>C, not -17. To get more accurate answers, we
should use floating-point arithmetic instead of integer. This requires some
changes in the program. Here is the second version:</strong>
<pre><strong>
   #include &lt;stdio.h&gt;

   /* Print Fahrenheit-Celsius table
    * for fahr = 0, 20, ..., 300; floating-point version
    */
   int main(void)
   {
     float fahr, celsius;
     float lower, upper, step;

     lower = 0;      /* lower limit of temperatuire scale */
     upper = 300;    /* upper limit */
     step = 20;      /* step size */

     fahr = lower;
     while (fahr &lt;= upper) {
         celsius = (5.0 / 9.0) * (fahr - 32.0); /* !Try to remove &quot;.0&quot;s here, and compile and run it! */
         printf("%3.0f %6.1f\n", fahr, celsius);
         fahr += step;
     }
     
     return 0;
   }</strong></pre>
This is much the same as before, except that <tt>fahr</tt> and <tt>celsius</tt>
are declared to be <tt>float</tt> and the formula for conversion is written in a
more natural way. We were unable to use <tt>5/9</tt> in the previous version
because integer division would truncate it to zero. A decimal point in a
constant indicates that it is floating point, however, so <tt>5.0/9.0</tt> is
not truncated because it is the ratio of two floating-point values.
<p>
If an arithmetic operator has integer operands, an integer operation is
performed. If an arithmetic operator has one floating-point operand and one
integer operand, however, the integer will be converted to floating point
before the operation is done. If we had written <tt>(fahr - 32)</tt>, the <tt>32</tt>
would be automatically converted to floating point. Nevertheless, writing
floating-point constants with explicit decimal points even when they have
integral values emphasizes their floating-point nature for human readers.
<p>
The detailed rules for when integers are converted to floating point are in
<a href="chapter2.html">Chapter 2</a>. For now, notice that the assignment
<pre>
   fahr = lower;
</pre>
and the test
<pre>
   while (fahr &lt;= upper)
</pre>
also work in the natural way - the <tt>int</tt> is converted to <tt>float</tt>
before the operation is done.
<p>
The <tt>printf</tt> conversion specification <tt>%3.0f</tt> says that a
floating-point number (here <tt>fahr</tt>) is to be printed at least three
characters wide, with no decimal point and no fraction digits. <tt>%6.1f</tt>
describes another number (<tt>celsius</tt>) that is to be printed at least six
characters wide, with 1 digit after the decimal point. The output looks like
this:
<pre>
     0   -17.8
    20    -6.7
    40     4.4
   ...
</pre>
Width and precision may be omitted from a specification: <tt>%6f</tt> says that
the number is to be at least six characters wide; <tt>%.2f</tt> specifies two
characters after the decimal point, but the width is not constrained; and
<tt>%f</tt> merely says to print the number as floating point.<br>
<br>
<table align="center" border=1>
<td><strong>&nbsp;<tt>%d</tt> </strong></td><td><strong>&nbsp;print as decimal integer</strong></td><tr>
<td><strong>&nbsp;<tt>%6d</tt> </strong></td><td><strong>&nbsp;print as decimal integer, at least 6 characters wide</strong></td><tr>
<td><strong>&nbsp;<tt>%f</tt> </strong></td><td><strong>&nbsp;print as floating point</strong></td><tr>
<td><strong>&nbsp;<tt>%6f</tt> </strong></td><td><strong>&nbsp;print as floating point, at least 6 characters wide</strong></td><tr>
<td><strong>&nbsp;<tt>%.2f</tt> </strong></td><td><strong>&nbsp;print as floating point, 2 characters after decimal point</strong></td><tr>
<td><strong>&nbsp;<tt>%6.2f</tt>&nbsp;&nbsp;</strong></td><td><strong>&nbsp;print as floating point, at least 6 wide and 2 after decimal point&nbsp;</strong></td>
</table>
<p>
Among others, <tt>printf</tt> also recognizes <tt>%o</tt> for octal, <tt>%x</tt>
for hexadecimal, <tt>%c</tt> for character, <tt>%s</tt> for character string and
<tt>%%</tt> for itself.
<p>
<strong>Exercise 1-3.</strong> Modify the temperature conversion program to print a
heading above the table.
<p>
<strong>Exercise 1-4.</strong> Write a program to print the corresponding Celsius to
Fahrenheit table.
<h2><a name="s1.3">1.3 The for statement</a></h2>
There are plenty of different ways to write a program for a particular task.
Let's try a variation on the temperature converter.
<pre><strong>   #include &lt;stdio.h&gt;

   /* Print Fahrenheit-Celsius table */
   int main(void)
   {
       int fahr;

       for (fahr = 0; fahr &lt;= 300; fahr += 20)
           printf("%3d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));

       return 0;
   }</strong></pre>
<strong>This produces the same answers, but it certainly looks different. One major
change is the elimination of most of the variables; only <tt>fahr</tt> remains,
and we have made it an <tt>int</tt>. The lower and upper limits and the step
size appear only as constants in the <tt>for</tt> statement, itself a new
construction, and the expression that computes the Celsius temperature now
appears as the third argument of <tt>printf</tt> instead of a separate
assignment statement.</strong>
<p>
This last change is an instance of a general rule - in any context where it
is permissible to use the value of some type, you can use a more complicated
expression of that type. Since the third argument of <tt>printf</tt> must be
a floating-point value to match the <tt>%6.1f</tt>, any floating-point
expression can occur here.
<p>
The <tt>for</tt> statement is a loop, a generalization of the <tt>while</tt>.
If you compare it to the earlier <tt>while</tt>, its operation should be clear.
Within the parentheses, there are three parts, separated by semicolons. The
first part, the initialization
<pre>
   fahr = 0
</pre>
is done once, before the loop proper is entered. The second part is the test
or condition that controls the loop:
<pre>
   fahr &lt;= 300
</pre>
This condition is evaluated; if it is true, the body of the loop (here a
single <tt>ptintf</tt>) is executed. Then the increment step
<pre>
   fahr += 20
</pre>
is executed, and the condition re-evaluated. The loop terminates if the
condition has become false. As with the <tt>while</tt>, the body of the loop can
be a single statement or a group of statements enclosed in braces. The
initialization, condition and increment can be any expressions.
<p>
The choice between <tt>while</tt> and <tt>for</tt> is arbitrary, based on which
seems clearer. The <tt>for</tt> is usually appropriate for loops in which the
initialization and increment are single statements and logically related,
since it is more compact than <tt>while</tt> and it keeps the loop control
statements together in one place.
<p>
<strong>Exercise 1-5.</strong> Modify the temperature conversion program to
print the table in reverse order, that is, from 300 degrees to 0.
<h2><a name="s1.4">1.4 Symbolic Constants</a></h2>
<strong>A final observation before we leave temperature conversion forever. It's bad
practice to bury ``magic numbers'' like 300 and 20 in a program; they convey
little information to someone who might have to read the program later, and
they are hard to change in a systematic way. One way to deal with magic
numbers is to give them meaningful names. A <tt>#define</tt> line defines a
<em>symbolic name or symbolic constant</em> to be a particular string of
characters:</strong>
<p>
&nbsp;&nbsp;<tt>#define</tt>   <em>name   replacement list</em>
<p>
Thereafter, any occurrence of <em>name</em> (not in quotes and not part of
another name) will be replaced by the corresponding <em>replacement text</em>.
The <em>name</em> has the same form as a variable name: a sequence of letters
and digits that begins with a letter. The <em>replacement text</em> can be any
sequence of characters; it is not limited to numbers.
<pre>
   #include &lt;stdio.h&gt;

   #define LOWER  0     /* lower limit of table */
   #define UPPER  300   /* upper limit */
   #define STEP   20    /* step size */

   /* Print Fahrenheit-Celsius table */
   int main(void)
   {
       int fahr;

       for (fahr = LOWER; fahr &lt;= UPPER; fahr += STEP)
           printf("%3d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
           
       return 0;
   }
</pre>
<p>The quantities <tt>LOWER</tt>, <tt>UPPER</tt> and <tt>STEP</tt> are symbolic
  constants, not variables, so they do not appear in declarations. Symbolic
  constant names are conventionally written in upper case so they can ber
  readily distinguished from lower case variable names. Notice that there is no
  semicolon at the end of a <tt>#define</tt> line.</p>
<p><strong>Exercise 1-A: #define a macro max(x, y) to return the max value of x and y. </strong></p>
<h2><a name="s1.5">1.5 Character Input and Output</a></h2>
We are going to consider a family of related programs for processing
character data. You will find that many programs are just expanded versions
of the prototypes that we discuss here.
<p>
The model of input and output supported by the standard library is very
simple. <strong>Text input or output, regardless of where it originates or where it
goes to, is dealt with as streams of characters. A <em>text stream</em> is a
sequence of characters divided into lines; each line consists of zero or more
characters followed by a newline character. It is the responsibility of the
library to make each input or output stream confirm this model; the C
programmer using the library need not worry about how lines are represented
outside the program.</strong>
<p>
The standard library provides several functions for reading or writing one
character at a time, of which <tt>getchar</tt> and <tt>putchar</tt> are the
simplest. Each time it is called, <tt>getchar</tt> reads the <em>next input
character</em> from a text stream and returns that as its value. That is, after
<pre>
   c = getchar();
</pre>
the variable <tt>c</tt> contains the next character of input. The characters
normally come from the keyboard; input from files is discussed in
<a href="chapter7.html">Chapter 7</a>.
<p>
The function <tt>putchar</tt> prints a character each time it is called:
<pre>
   putchar(c);
</pre>
prints the contents of the integer variable <tt>c</tt> as a character, usually
on the screen. Calls to <tt>putchar</tt> and <tt>printf</tt> may be interleaved;
the output will appear in the order in which the calls are made.

<h3><a name="s1.5.1">1.5.1 File Copying</a></h3>
<strong>Given <tt>getchar</tt> and <tt>putchar</tt>, you can write a surprising
amount of useful code without knowing anything more about input and output.
The simplest example is a program that copies its input to its output one
character at a time:</strong>
<pre>
<em>read a character</em>
    while (<em>charater is not end-of-file indicator</em>)
        <em>output the character just read
        read a character</em>
</pre>
Converting this into C gives:
<pre><strong>   #include &lt;stdio.h&gt;

   /* copy input to output; 1st version  */
   int main(void)
   {
       int c;

       c = getchar();
       while (c != EOF) {
           putchar(c);
           c = getchar();
       }

       return 0;
   }</strong></pre>
The relational operator <tt>!=</tt> means ``not equal to''.
<p>
What appears to be a character on the keyboard or screen is of course, like
everything else, stored internally just as a bit pattern. The type <tt>char</tt>
is specifically meant for storing such character data, but any integer type
can be used. We used <tt>int</tt> for a subtle but important reason.
<p><strong>
The problem is distinguishing the end of input from valid data. The solution
is that <tt>getchar</tt> returns a distinctive value when there is no more
input, a value that cannot be confused with any real character. This value
is called <tt>EOF</tt>, for ``end of file''. We must declare <tt>c</tt> to be
a type big enough to hold any value that <tt>getchar</tt> returns. We can't use
<tt>char</tt> since <tt>c</tt> must be big enough to hold <tt>EOF</tt> in
addition to any possible <tt>char</tt>. Therefore we use <span class="STYLE2"><tt>int</tt></span>.
</strong>
<p>
<tt>EOF</tt> is an integer defined in </tt>&lt;stdio.h&gt;</tt>, but the specific numeric
value doesn't matter as long as it is not the same as any <tt>char</tt> value.
By using the symbolic constant, we are assured that nothing in the program
depends on the specific numeric value.
<p>
The program for copying would be written more concisely by experienced C
programmers. In C, any assignment, such as
<pre>
   c = getchar();
</pre>
is an expression and has a value, which is the value of the left hand side
after the assignment. This means that a assignment can appear as part of a
larger expression. If the assignment of a character to <tt>c</tt> is put inside
the test part of a <tt>while</tt> loop, the copy program can be written this
way:
<pre><strong>   #include &lt;stdio.h&gt;

   /* copy input to output; 2nd version  */
   int main(void)
   {
       int c;

       while ((c = getchar()) != EOF)
           putchar(c);

       return 0;
   }</strong></pre>
The <tt>while</tt> gets a character, assigns it to <tt>c</tt>, and then tests
whether the character was the end-of-file signal. If it was not, the body of
the <tt>while</tt> is executed, printing the character. The <tt>while</tt> then
repeats. When the end of the input is finally reached, the <tt>while</tt>
terminates and so does <tt>main</tt>.
<p>
This version centralizes the input - there is now only one reference to
<tt>getchar</tt> - and shrinks the program. The resulting program is more
compact, and, once the idiom is mastered, easier to read. You'll see this
style often. (It's possible to get carried away and create impenetrable code,
however, a tendency that we will try to curb.)
<p>
The parentheses around the assignment, within the condition are necessary.
The <em>precedence</em> of <tt>!=</tt> is higher than that of <tt>=</tt>, which
means that in the absence of parentheses the relational test <tt>!=</tt> would
be done before the assignment <tt>=</tt>. So the statement
<pre>
   c = getchar() != EOF
</pre>
is equivalent to
<pre>
   c = (getchar() != EOF)
</pre>
This has the undesired effect of setting <tt>c</tt> to 0 or 1, depending on
whether or not the call of <tt>getchar</tt> returned end of file. (More on this
in <a href="chapter2.html">Chapter 2</a>.)
<p>
<strong>Exercsise 1-6.</strong> Verify that the expression
<tt>getchar() != EOF</tt> is 0 or 1.
<p>
<strong>Exercise 1-7.</strong> Write a program to print the value of
<tt>EOF</tt>.
<h3><a name="s1.5.2">1.5.2 Character Counting</a></h3>
<strong>The next program counts characters; it is similar to the copy program.</strong>
<pre><strong>   #include &lt;stdio.h&gt;

   /* count characters in input; 1st version */
   int main(void)
   {
       long nc;

       nc = 0;
       while (getchar() != EOF)
           ++nc;
       printf("%ld\n", nc);
       
       return 0;
   }</strong></pre>
The statement
<pre>
   ++nc;
</pre>
presents a new operator, <tt>++</tt>, which means <em>increment by one</em>.
You could instead write <tt>nc = nc + 1</tt> but <tt>++nc</tt> is more
concise and often more efficient. There is a corresponding operator
<tt>--</tt> to decrement by 1. The operators <tt>++</tt> and <tt>--</tt> can
be either prefix operators (<tt>++nc</tt>) or postfix operators
(<tt>nc++</tt>); these two forms have different values in expressions, as
will be shown in <a href="chapter2.html">Chapter 2</a>, but <tt>++nc</tt> and
<tt>nc++</tt> both increment <tt>nc</tt>. For the moment we will will stick
to the prefix form.
<p>
The character counting program accumulates its count in a <tt>long</tt>
variable instead of an int. <tt>long</tt> integers are at least 32 bits.
Although on some machines, <tt>int</tt> and <tt>long</tt> are the same size,
on others an <tt>int</tt> is 16 bits, with a maximum value of 32767, and it
would take relatively little input to overflow an <tt>int</tt> counter. The
conversion specification <tt>%ld</tt> tells <tt>printf</tt> that the
corresponding argument is a <tt>long</tt> integer.
<p>
It may be possible to cope with even bigger numbers by using a <tt>double</tt>
(double precision <tt>float</tt>). We will also use a <tt>for</tt> statement
instead of a <tt>while</tt>, to illustrate another way to write the loop.
<pre><strong>    #include &lt;stdio.h&gt;

   /* count characters in input; 2nd version */
   int main(void)
   {
       double nc;

       <span class="STYLE2">for (nc = 0; gechar() != EOF; ++nc)
           ;</span>
       printf("%.0f\n", nc);
       
       return 0;
   }
</strong></pre>
<tt>printf</tt> uses <tt>%f</tt> for both <tt>float</tt> and <tt>double</tt>;
<tt>%.0f</tt> suppresses the printing of the decimal point and the fraction
part, which is zero.
<p>
The body of this <tt>for</tt> loop is empty, because all the work is done in
the test and increment parts. But the grammatical rules of C require that a
<tt>for</tt> statement have a body. The isolated semicolon, called a <em>null
statement</em>, is there to satisfy that requirement. We put it on a separate
line to make it visible.
<p>
Before we leave the character counting program, observe that if the input
contains no characters, the <tt>while</tt> or <tt>for</tt> test fails on the very
first call to <tt>getchar</tt>, and the program produces zero, the right answer.
This is important. One of the nice things about <tt>while</tt> and <tt>for</tt>
is that they test at the top of the loop, before proceeding with the body. If
there is nothing to do, nothing is done, even if that means never going
through the loop body. Programs should act intelligently when given
zero-length input. The <tt>while</tt> and <tt>for</tt> statements help ensure
that programs do reasonable things with boundary conditions.
<h3><a name="s1.5.3">1.5.3 Line Counting</a></h3>
The next program counts input lines. As we mentioned above, the standard
library ensures that an input text stream appears as a sequence of lines,
each terminated by a newline. Hence, counting lines is just counting
newlines:
<pre><strong>   #include &lt;stdio.h&gt;

   /* count lines in input */
   int main(void)
   {
       int c, nl;

       nl = 0;
       while ((c = getchar()) != EOF)
       {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (c == '\n')
            &nbsp;&nbsp;&nbsp;++nl;
       }

       printf("%d\n", nl);
       
       return 0;
   }</strong></pre>
The body of the <tt>while</tt> now consists of an <tt>if</tt>, which in turn
controls the increment <tt>++nl</tt>. The <tt>if</tt> statement tests the
parenthesized condition, and if the condition is true, executes the statement
(or group of statements in braces) that follows. We have again indented to
show what is controlled by what.
<p>
The double equals sign <tt>==</tt> is the C notation for ``is equal to'' (like
Pascal's single <tt>=</tt> or Fortran's <tt>.EQ.</tt>). This symbol is used to
distinguish the equality test from the single <tt>=</tt> that C uses for
assignment. A word of caution: newcomers to C occasionally write <tt>=</tt> when
they mean <tt>==</tt>. As we will see in <a href="chapter2.html">Chapter 2</a>,
the result is usually a legal expression, so you will get no warning.
<p>
A character written between single quotes represents an integer value equal
to the numerical value of the character in the machine's character set. This
is called a <em>character constant</em>, although it is just another way to
write a small integer. So, for example, <tt>'A'</tt> is a character constant; in
the ASCII character set its value is 65, the internal representation of the
character <tt>A</tt>. Of course, <tt>'A'</tt> is to be preferred over <tt>65</tt>: its
meaning is obvious, and it is independent of a particular character set.
<p>
The escape sequences used in string constants are also legal in character
constants, so <tt>'\n'</tt> stands for the value of the newline character,
which is 10 in ASCII. You should note carefully that <tt>'\n'</tt> is a single
character, and in expressions is just an integer; on the other hand,
<tt>'\n'</tt> is a string constant that happens to contain only one character.
The topic of strings versus characters is discussed further in
<a href="chapter2.html">Chapter 2</a>.
<p>
<strong>Exercise 1-8.</strong> Write a program to count blanks, tabs, and newlines.
<p>
<strong>*Exercise 1-9.</strong> Write a program to copy its input to its output,
replacing each string of one or more blanks by a single blank.
<p>
<strong>Exercise 1-10.</strong> Write a program to copy its input to its output,
replacing each tab by <tt>\t</tt>, each backspace by <tt>\b</tt>, and each
backslash by <tt>\\</tt>. This makes tabs and backspaces visible in an
unambiguous way.
<h3><a name="s1.5.4">1.5.4 Word Counting</a></h3>
The fourth in our series of useful programs counts lines, words, and
characters, with the loose definition that a word is any sequence of
characters that does not contain a blank, tab or newline. This is a
bare-bones version of the UNIX program <tt>wc</tt>.
<pre><strong>   #include &lt;stdio.h&gt;

   #define IN   1  /* inside a word */
   #define OUT  0  /* outside a word */

   /* count lines, words, and characters in input */
   int main(void)
   {
       int c, nl, nw, nc, state;

       state = OUT;
       nl = nw = nc = 0;
       while ((c = getchar()) != EOF) {
           ++nc;
           if (c == '\n')
               ++nl;
           if (c == ' ' || c == '\n' || c = '\t')
               state = OUT;
           else if (state == OUT) {
               state = IN;
               ++nw;
           }
       }
       printf("%d %d %d\n", nl, nw, nc);
       
       return 0;
   }</strong></pre>
Every time the program encounters the first character of a word, it counts
one more word. The variable <tt>state</tt> records whether the program is
currently in a word or not; initially it is ``not in a word'', which is
assigned the value <tt>OUT</tt>. We prefer the symbolic constants <tt>IN</tt>
and <tt>OUT</tt> to the literal values 1 and 0 because they make the program
more readable. In a program as tiny as this, it makes little difference, but
in larger programs, the increase in clarity is well worth the modest extra
effort to write it this way from the beginning. You'll also find that it's
easier to make extensive changes in programs where magic numbers appear only
as symbolic constants.
<p>
The line
<pre>
   nl = nw = nc = 0;
</pre>
sets all three variables to zero. This is not a special case, but a
consequence of the fact that an assignment is an expression with the value
and assignments associated from right to left. It's as if we had written
<pre>
   nl = (nw = (nc = 0));
</pre>
The operator <tt>||</tt> means OR, so the line
<pre>
   if (c == ' ' || c == '\n' || c = '\t')
</pre>
says ``if <tt>c</tt> is a blank <em>or</em> <tt>c</tt> is a newline
<em>or</em> <tt>c</tt> is a tab''. (Recall that the escape sequence
<tt>\t</tt> is a visible representation of the tab character.) There is a
corresponding operator <tt>&amp;&amp;</tt> for AND; its precedence is just
higher than <tt>||</tt>. Expressions connected by <tt>&amp;&amp;</tt> or
<tt>||</tt> are evaluated left to right, and it is guaranteed that evaluation
will stop as soon as the truth or falsehood is known. If <tt>c</tt> is a
blank, there is no need to test whether it is a newline or tab, so these
tests are not made. This isn't particularly important here, but is significant
in more complicated situations, as we will soon see.
<p>
The example also shows an <tt>else</tt>, which specifies an alternative
action if the condition part of an <tt>if</tt> statement is false. The
general form is
<pre>
   if (<em>expression</em>)
       <em>statement<sub>1</sub></em>
   else
       <em>statement<sub>2</sub></em>
</pre>
One and only one of the two statements associated with an <tt>if-else</tt> is
performed. If the <em>expression</em> is true, <em>statement<sub>1</sub></em> is
executed; if not, <em>statement<sub>2</sub></em> is executed. Each
<em>statement</em> can be a single statement or several in braces. In the
word count program, the one after the <tt>else</tt> is an <tt>if</tt> that
controls two statements in braces.
<p>
<strong>Exercise 1-11.</strong> How would you test the word count program?
What kinds of input are most likely to uncover bugs if there are any?
<p>
<strong>Exercise 1-12.</strong> Write a program that prints its input one
word per line.
<p><strong>Exercise 1-A. Write your own version of Linux command `wc'. 
</strong>

<h2><a name="s1.6">1.6 Arrays</a></h2>
Let is write a program to count the number of occurrences of each digit, of
white space characters (blank, tab, newline), and of all other characters.
This is artificial, but it permits us to illustrate several aspects of C in
one program.
<p>
There are twelve categories of input, so it is convenient to use an array to
hold the number of occurrences of each digit, rather than ten individual
variables. Here is one version of the program:
<pre>
   #include &lt;stdio.h&gt;

   /* count digits, white space, others */
   int main(void)
   {
       int c, i, nwhite, nother;
       int ndigit[10];

       nwhite = nother = 0;
       for (i = 0; i &lt; 10; ++i)
           ndigit[i] = 0;

       while ((c = getchar()) != EOF)
       {
           if (c &gt;= '0' && c &lt;= '9')
               ++ndigit[c-'0'];
           else if (c == ' ' || c == '\n' || c == '\t')
               ++nwhite;
           else
               ++nother;
       }
       
       printf("digits =");
       for (i = 0; i &lt; 10; ++i)
           printf(" %d", ndigit[i]);
       printf(", white space = %d, other = %d\n",
           nwhite, nother);
           
       return 0;
   }
</pre>
The output of this program on itself is
<pre>
   digits = 9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345
</pre>
The declaration
<pre>
   int ndigit[10];
</pre>
declares <tt>ndigit</tt> to be an array of 10 integers. Array subscripts always
start at zero in C, so the elements are <tt>ndigit[0], ndigit[1], ...,
ndigit[9]</tt>. This is reflected in the <tt>for</tt> loops that initialize
and print the array.
<p>
A subscript can be any integer expression, which includes integer variables
like <tt>i</tt>, and integer constants.
<p>
This particular program relies on the properties of the character
representation of the digits. For example, the test
<pre>
   if (c &gt;= '0' && c &lt;= '9')
</pre>
determines whether the character in <tt>c</tt> is a digit. If it is, the
numeric value of that digit is
<pre>
   c - '0'
</pre>
This works only if <tt>'0', '1', ..., '9'</tt> have consecutive increasing
values. Fortunately, this is true for all character sets.
<p>
By definition, <tt>char</tt>s are just small integers, so <tt>char</tt>
variables and constants are identical to <tt>int</tt>s in arithmetic
expressions. This is natural and convenient; for example <tt>c-'0'</tt> is an
integer expression with a value between 0 and 9 corresponding to the
character <tt>'0'</tt> to <tt>'9'</tt> stored in <tt>c</tt>, and thus a valid
subscript for the array <tt>ndigit</tt>.
<p>
The decision as to whether a character is a digit, white space, or something
else is made with the sequence
<pre>
   if (c &gt;= '0' && c &lt;= '9')
       ++ndigit[c-'0'];
   else if (c == ' ' || c == '\n' || c == '\t')
       ++nwhite;
   else
       ++nother;
</pre>
The pattern
<pre>
   if (<em>condition<sub>1</sub></em>)
       <em>statement<sub>1</sub></em>
   else if (<em>condition<sub>2</sub></em>)
       <em>statement<sub>2</sub></em>
       ...
       ...
   else
       <em>statement<sub>n</sub></em>
</pre>
occurs frequently in programs as a way to express a multi-way decision. The
<em>conditions</em> are evaluated in order from the top until some
<em>condition</em> is satisfied; at that point the corresponding
<em>statement</em> part is executed, and the entire construction is finished.
(Any <em>statement</em> can be several statements enclosed in braces.) If
none of the conditions is satisfied, the <em>statement</em> after the final
<tt>else</tt> is executed if it is present. If the final <tt>else</tt> and
<em>statement</em> are omitted, as in the word count program, no action takes
place. There can be any number of
<p>
<tt>else if</tt>(<em>condition</em>)<br>
&nbsp;&nbsp;<em>statement</em>
<p>
groups between the initial <tt>if</tt> and the final <tt>else</tt>.
<p>
As a matter of style, it is advisable to format this construction as we have
shown; if each <tt>if</tt> were indented past the previous <tt>else</tt>, a long
sequence of decisions would march off the right side of the page.
<p>
The <tt>switch</tt> statement, to be discussed in <a href="chapter4.html">Chapter 4</a>,
provides another way to write a multi-way branch that is particulary suitable
when the condition is whether some integer or character expression matches
one of a set of constants. For contrast, we will present a <tt>switch</tt>
version of this program in <a href="chapter3.html#s3.4">Section 3.4</a>.
<p>
<strong>*Exercise 1-13.</strong> Write a program to print a histogram of the
lengths of words in its input. It is easy to draw the histogram with the bars
horizontal; a vertical orientation is more challenging.
<p>
<strong>Exercise 1-14.</strong> Write a program to print a histogram of the
frequencies of different characters in its input.
<h2><a name="s1.7">1.7 Functions</a></h2>
In C, a function is equivalent to a subroutine or function in Fortran, or a
procedure or function in Pascal. A function provides a convenient way to
encapsulate some computation, which can then be used without worrying about
its implementation. With properly designed functions, it is possible to
ignore <em>how</em> a job is done; knowing <em>what</em> is done is sufficient. C
makes the sue of functions easy,  convinient and efficient; you will often
see a short function defined and called only once, just because it clarifies
some piece of code.
<p>
So far we have used only functions like <tt>printf</tt>, <tt>getchar</tt> and
<tt>putchar</tt> that have been provided for us; now it's time to write a few
of our own. Since C has no exponentiation operator like the <tt>**</tt> of
Fortran, let us illustrate the mechanics of function definition by writing a
function <tt>power(m,n)</tt> to raise an integer <tt>m</tt> to a positive
integer power <tt>n</tt>. That is, the value of <tt>power(2,5)</tt> is 32.
This function is not a practical exponentiation routine, since it handles
only positive powers of small integers, but it's good enough for
illustration.(The standard library contains a function <tt>pow(x,y)</tt> that
computes <em>x<sup>y</sup></em>.)
<p>
Here is the function <tt>power</tt> and a main program to exercise it, so you
can see the whole structure at once.
<pre><strong>    #include &lt;stdio.h&gt;

    static int power(int m, int n);

    /* test power function */
    int main(void)
    {
        int i;

        for (i = 0; i &lt; 10; ++i)
            printf("%d %d %d\n", i, power(2, i), power(-3, i));

        return 0;
    }

    /* power:  raise base to n-th power; n &gt;= 0 */
    static int power(int base, int n)
    {
        int i,  p;

        p = 1;
        for (i = 1; i &lt;= n; ++i)
            p = p * base;

        return p;
    }</strong></pre>
A function definition has this form:
<pre>
return-type function-name(parameter declarations, if any)
{
   declarations
   statements
}
</pre>
Function definitions can appear in any order, and in one source file or
several, although no function can be split between files. If the source
program appears in several files, you may have to say more to compile and
load it than if it all appears in one, but that is an operating system
matter, not a language attribute. For the moment, we will assume that both
functions are in the same file, so whatever you have learned about running C
programs will still work.
<p>
The function <tt>power</tt> is called twice by <tt>main</tt>, in the line
<pre>
   printf("%d %d %d\n", i, power(2, i), power(-3, i));
</pre>
Each call passes two arguments to <tt>power</tt>, which each time returns an
integer to be formatted and printed. In an expression, <tt>power(2,i)</tt> is an
integer just as <tt>2</tt> and <tt>i</tt> are. (Not all functions produce an
integer value; we will take this up in <a href="chapter4.html">Chapter 4</a>.)
<p>
The first line of <tt>power</tt> itself,
<pre>
    static int power(int base, int n);
</pre>
declares the parameter types and names, and the type of the result that the
function returns. The names used by <tt>power</tt> for its parameters are local
to <tt>power</tt>, and are not visible to any other function: other routines
can use the same names without conflict. This is also true of the variables
<tt>i</tt> and <tt>p</tt>: the <tt>i</tt> in <tt>power</tt> is unrelated to
the <tt>i</tt> in <tt>main</tt>.
<p>
We will generally use <em>parameter</em> for a variable named in the
parenthesized list in a function. The terms <em>formal argument</em> and
<em>actual argument</em> are sometimes used for the same distinction.
<p>
The value that <tt>power</tt> computes is returned to <tt>main</tt> by the
<tt>return</tt>: statement. Any expression may follow <tt>return</tt>:
<pre>
   return <em>expression</em>;
</pre>
A function need not return a value; a return statement with no expression
causes control, but no useful value, to be returned to the caller, as does
``falling off the end'' of a function by reaching the terminating right
brace. And the calling function can ignore a value returned by a function.
<p>
You may have noticed that there is a <tt>return</tt> statement at the end of
<tt>main</tt>. Since <tt>main</tt> is a function like any other, it may return a
value to its caller, which is in effect the environment in which the program
was executed. Typically, a return value of zero implies normal termination;
non-zero values signal unusual or erroneous termination conditions. In the
interests of simplicity, we have omitted <tt>return</tt> statements from our
<tt>main</tt> functions up to this point, but we will include them hereafter, as
a reminder that programs should return status to their environment.
<p>
The declaration
<pre>
    static int power(int base, int n);
</pre>
just before <tt>main</tt> says that <tt>power</tt> is a function that expects two
<tt>int</tt> arguments and returns an <tt>int</tt>. This declaration, which is
called a <em>function prototype</em>, has to agree with the definition and uses
of <tt>power</tt>. It is an error if the definition of a function or any uses of
it do not agree with its prototype.
<p>
parameter names need not agree. Indeed, parameter names are optional in a
function prototype, so for the prototype we could have written
<pre>
    static int power(int, int);
</pre>
Well-chosen names are good documentation however, so we will often use them.
<p>
A note of history: the biggest change between ANSI C and earlier versions is
how functions are declared and defined. In the original definition of C, the
<tt>power</tt> function would have been written like this:
<pre>
   /* power:  raise base to n-th power; n &gt;= 0 */
   /*         (old-style version) */
   power(base, n)
   int base, n;
   {
       int i, p;

       p = 1;
       for (i = 1; i &lt;= n; ++i)
           p = p * base;
       return p;
   }
</pre>
The parameters are named between the parentheses, and their types are
declared before opening the left brace; undeclared parameters are taken as
<tt>int</tt>. (The body of the function is the same as before.)
<p>
The declaration of <tt>power</tt> at the beginning of the program would have
looked like this:
<pre>
    int power();
</pre>
No parameter list was permitted, so the compiler could not readily check that
<tt>power</tt> was being called correctly. Indeed, since by default <tt>power</tt>
would have been assumed to return an <tt>int</tt>, the entire declaration might
well have been omitted.
<p><strong>
The new syntax of function prototypes makes it much easier for a compiler to
detect errors in the number of arguments or their types. The old style of
declaration and definition still works in ANSI C, at least for a transition
period, but we strongly recommend that you use the new form when you have a
compiler that supports it. <br>
(本书是1988年出版的，200X年当然应该采用新的风格了。)
</strong>
<p>
<strong>Exercise 1.15.</strong> Rewrite the temperature conversion program of
<a href="#s1.2">Section 1.2</a> to use a function for conversion.
<h2><a name="s1.8">1.8 Arguments - Call by Value</a></h2>
<p><strong>One aspect of C functions may be unfamiliar to programmers who are used to
  some other languages, particulary Fortran. In C, all function arguments are
  passed ``by value.'' This means that the called function is given the values
  of its arguments in temporary variables rather than the originals. This leads
  to some different properties than are seen with ``call by reference''
  languages like Fortran or with <tt>var</tt> parameters in Pascal, in which the
  called routine has access to the original argument, not a local copy.</strong></p>
<p><strong>注意比较 Call by value and by reference 的区别。特别的，可以通过实现以下两个程序来理解 Call by value:</strong></p>
<p><strong>1. 交换两个整数的取值，例如：void swap(int a, int b) vs. void swap(int *a, int *b) </strong></p>
<p><strong>2. 修改一个指针指向的内存的值 vs 修改一个指针的值，例如：void adjust(char *p) vs. void adjust(char **p) </strong></p>
<p>Call by value is an asset, however, not a liability. It usually leads to more
compact programs with fewer extraneous variables, because parameters can be
treated as conveniently initialized local variables in the called routine.
For example, here is a version of <tt>power</tt> that makes use of this property.</p>
<pre>
   /* power:  raise base to n-th power; n &gt;= 0; version 2 */
   int power(int base, int n)
   {
       int p;

       for (p = 1; n &gt; 0; --n)
           p = p * base;
       return p;
   }
</pre>
The parameter <tt>n</tt> is used as a temporary variable, and is counted down (a
<tt>for</tt> loop that runs backwards) until it becomes zero; there is no longer
a need for the variable <tt>i</tt>. Whatever is done to <tt>n</tt> inside <tt>
power</tt> has no effect on the argument that <tt>power</tt> was originally called
with.
<p>
When necessary, it is possible to arrange for a function to modify a variable
in a calling routine. The caller must provide the <em>address</em> of the variable
to be set (technically a <em>pointer</em> to the variable), and the called
function must declare the parameter to be a pointer and access the variable
indirectly through it. We will cover pointers in
<a href="chapter5.html">Chapter 5</a>.
<p>
The story is different for arrays. When the name of an array is used as an
argument, the value passed to the function is the location or address of the
beginning of the array - there is no copying of array elements. By
subscripting this value, the function can access and alter any argument of
the array. This is the topic of the next section.
<h2><a name="s1.9">1.9 Character Arrays</a></h2>
The most common type of array in C is the array of characters. To illustrate
the use of character arrays and functions to manipulate them, let's write a
program that reads a set of text lines and prints the longest. The outline is
simple enough:
<pre>
   while (<em>there's another line</em>)
       if (<em>it's longer than the previous longest</em>)
           (<em>save it</em>)
           (<em>save its length</em>)
   <em>print longest line</em>
</pre>
This outline makes it clear that the program divides naturally into pieces.
One piece gets a new line, another saves it, and the rest controls the
process.
<p>
Since things divide so nicely, it would be well to write them that way too.
Accordingly, let us first write a separate function <tt>getline</tt> to fetch
the next line of input. We will try to make the function useful in other
contexts. At the minimum, <tt>getline</tt> has to return a signal about possible
end of file; a more useful design would be to return the length of the line,
or zero if end of file is encountered. Zero is an acceptable end-of-file
return because it is never a valid line length. Every text line has at least
one character; even a line containing only a newline has length 1.
<p>
When we find a line that is longer than the previous longest line, it must be
saved somewhere. This suggests a second function, <tt>copy</tt>, to copy the new
line to a safe place.
<p>
Finally, we need a main program to control <tt>getline</tt> and <tt>copy</tt>.
Here is the result.
<pre>
   #include &lt;stdio.h&gt;
   #define MAXLINE 1000   /* maximum input line length */

   int getline(char line[], int maxline);
   void copy(char to[], char from[]);

   /* print the longest input line */
   int main(void)
   {
       int len;            /* current line length */
       int max;            /* maximum length seen so far */
       char line[MAXLINE];    /* current input line */
       char longest[MAXLINE]; /* longest line saved here */

       max = 0;
       while ((len = getline(line, MAXLINE)) &gt; 0)
           if (len &gt; max) {
               max = len;
               copy(longest, line);
           }
       if (max &gt; 0)  /* there was a line */
           printf("%s", longest);
       return 0;
   }

   /* getline:  read a line into s, return length  */
   int getline(char s[],int lim)
   {
       int c, i;

       for (i=0; i &lt; lim-1 && (c=getchar())!=EOF && c!='\n'; ++i)
           s[i] = c;
       if (c == '\n') {
           s[i] = c;
           ++i;
       }
       s[i] = '\0';
       return i;
   }

   /* copy:  copy 'from' into 'to'; assume to is big enough */
   void copy(char to[], char from[])
   {
       int i;

       i = 0;
       while ((to[i] = from[i]) != '\0')
           ++i;
   }
</pre>
The functions <tt>getline</tt> and <tt>copy</tt> are declared at the
beginning of the program, which we assume is contained in one file.
<p>
<tt>main</tt> and <tt>getline</tt> communicate through a pair of arguments and a
returned value. In <tt>getline</tt>, the arguments are declared by the line
<pre>
   int getline(char s[], int lim);
</pre>
which specifies that the first argument, <tt>s</tt>, is an array, and the
second, <tt>lim</tt>, is an integer. The purpose of supplying the size of an
array in a declaration is to set aside storage. The length of an array <tt>s</tt>
is not necessary in <tt>getline</tt> since its size is set in <tt>main</tt>.
<tt>getline</tt> uses <tt>return</tt> to send a value back to the caller, just
as the function <tt>power</tt> did. This line also declares that <tt>getline</tt>
returns an <tt>int</tt>; since <tt>int</tt> is the default return type, it
could be omitted.
<p>
Some functions return a useful value; others, like <tt>copy</tt>, are used only
for their effect and return no value. The return type of <tt>copy</tt> is
<tt>void</tt>, which states explicitly that no value is returned.
<p>
<tt>getline</tt> puts the character <tt>'\0'</tt> (the <em>null character</em>,
whose value is zero) at the end of the array it is creating, to mark the end
of the string of characters. This conversion is also used by the C language:
when a string constant like
<pre>
   "hello\n"
</pre>
<strong>appears in a C program, it is stored as an array of characters containing the
characters in the string and terminated with a <tt>'\0'</tt> to mark the end.</strong>
<p align="center">
  <strong><img src="pic11.gif"></strong>
<p>
The <tt>%s</tt> format specification in <tt>printf</tt> expects the
corresponding argument to be a string represented in this form. <tt>copy</tt>
also relies on the fact that its input argument is terminated with a
<tt>'\0'</tt>, and copies this character into the output.
<p>
It is worth mentioning in passing that even a program as small as this one
presents some sticky design problems. For example, what should <tt>main</tt> do
if it encounters a line which is bigger than its limit? <tt>getline</tt> works
safely, in that it stops collecting when the array is full, even if no
newline has been seen. By testing the length and the last character returned,
<tt>main</tt> can determine whether the line was too long, and then cope as it
wishes. In the interests of brevity, we have ignored this issue.
<p>
There is no way for a user of <tt>getline</tt> to know in advance how long an
input line might be, so <tt>getline</tt> checks for overflow. On the other hand,
the user of <tt>copy</tt> already knows (or can find out) how big the strings
are, so we have chosen not to add error checking to it.
<p>
<strong>Exercise 1-16.</strong> Revise the main routine of the longest-line
program so it will correctly print the length of arbitrary long input lines,
and as much as possible of the text.
<p>
<strong> Exercise 1-17.</strong> Write a program to print all input lines
that are longer than 80 characters.
<p>
<strong> Exercise 1-18.</strong> Write a program to remove trailing blanks
and tabs from each line of input, and to delete entirely blank lines.
<p>
<strong> *Exercise 1-19.</strong> <strong>Write a function <tt>reverse(s)</tt> that
reverses the character string <tt>s</tt>.</strong> Use it to write a program that
reverses its input a line at a time.
<h2><a name="s1.10">1.10 External Variables and Scope</a></h2>
The variables in <tt>main</tt>, such as <tt>line</tt>, <tt>longest</tt>, etc.,
are private or local to <tt>main</tt>. Because they are declared within <tt>main</tt>,
no other function can have direct access to them. The same is true of the
variables in other functions; for example, the variable <tt>i</tt> in <tt>
getline</tt> is unrelated to the <tt>i</tt> in copy. Each local variable in a
function comes into existence only when the function is called, and
disappears when the function is exited. This is why such variables are
usually known as <em>automatic</em> variables, following terminology in other
languages. We will use the term automatic henceforth to refer to these local
variables. (<a href="chapter4.html">Chapter 4</a> discusses the <tt>static</tt> storage
class, in which local variables do retain their values between calls.)
<p>
Because automatic variables come and go with function invocation, they do not
retain their values from one call to the next, and must be explicitly set
upon each entry. If they are not set, they will contain garbage.
<p>
As an alternative to automatic variables, it is possible to define variables
that are <em>external</em> to all functions, that is, variables that can be
accessed by name by any function. (This mechanism is rather like Fortran
COMMON or Pascal variables declared in the outermost block.) Because external
variables are globally accessible, they can be used instead of argument lists
to communicate data between functions. Furthermore, because external
variables remain in existence permanently, rather than appearing and
disappearing as functions are called and exited, they retain their values
even after the functions that set them have returned.
<p>
An external variable must be <em>defined</em>, exactly once, outside of any
function; this sets aside storage for it. The variable must also be
<em>declared</em> in each function that wants to access it; this states the
type of the variable. The declaration may be an explicit <tt>extern</tt>
statement or may be implicit from context. To make the discussion concrete,
let us rewrite the longest-line program with <tt>line</tt>, <tt>longest</tt>,
and <tt>max</tt> as external variables. This requires changing the calls,
declarations, and bodies of all three functions.
<pre>
   #include &lt;stdio.h&gt;

   #define MAXLINE 1000    /* maximum input line size */

   int max;                /* maximum length seen so far */
   char line[MAXLINE];     /* current input line */
   char longest[MAXLINE];  /* longest line saved here */

   int getline(void);
   void copy(void);

   /* print longest input line; specialized version */
   int main(void)
   {
       int len;
       extern int max;
       extern char longest[];

       max = 0;
       while ((len = getline()) &gt; 0)
           if (len &gt; max) {
               max = len;
               copy();
           }
       if (max &gt; 0)  /* there was a line */
           printf("%s", longest);
       return 0;
   }

   /* getline:  specialized version */
   int getline(void)
   {
       int c, i;
       extern char line[];

       for (i = 0; i &lt; MAXLINE - 1
            && (c=getchar)) != EOF && c != '\n'; ++i)
                line[i] = c;
       if (c == '\n') {
           line[i] = c;
           ++i;
       }
       line[i] = '\0';
       return i;
   }

   /* copy: specialized version */
   void copy(void)
   {
       int i;
       extern char line[], longest[];

       i = 0;
       while ((longest[i] = line[i]) != '\0')
           ++i;
   }
</pre>
The external variables in <tt>main</tt>, <tt>getline</tt> and <tt>copy</tt> are
defined by the first lines of the example above, which state their type and
cause storage to be allocated for them. Syntactically, external definitions
are just like definitions of local variables, but since they occur outside of
functions, the variables are external. Before a function can use an external
variable, the name of the variable must be made known to the function; the
declaration is the same as before except for the added keyword <tt>extern</tt>.
<p>
In certain circumstances, the <tt>extern</tt> declaration can be omitted. If the
definition of the external variable occurs in the source file before its use
in a particular function, then there is no need for an <tt>extern</tt>
declaration in the function. The <tt>extern</tt> declarations in <tt>main</tt>,
<tt>getline</tt> and <tt>copy</tt> are thus redundant. In fact, common practice is
to place definitions of all external variables at the beginning of the source
file, and then omit all extern declarations.
<p>
If the program is in several source files, and a variable is defined in <em>
file1</em> and used in <em>file2</em> and <em>file3</em>, then <tt>extern</tt>
declarations are needed in <em>file2</em> and <em>file3</em> to connect the
occurrences of the variable. The usual practice is to collect <tt>extern</tt>
declarations of variables and functions in a separate file, historically
called a <em>header</em>, that is included by <tt>#include</tt> at the front of
each source file. The suffix <tt>.h</tt> is conventional for header names. The
functions of the standard library, for example, are declared in headers like
<tt>&lt;stdio.h&gt;</tt>. This topic is discussed at length in
<a href="chapter4.html">Chapter 4</a>, and the library itself in
<a href="chapter7.html">Chapter 7</a> and
<a href="appb.html">Appendix B</a>.
<p>
Since the specialized versions of <tt>getline</tt> and <tt>copy</tt> have no
arguments, logic would suggest that their prototypes at the beginning of the
file should be <tt>getline()</tt> and <tt>copy()</tt>. But for compatibility
with older C programs the standard takes an empty list as an old-style
declaration, and turns off all argument list checking; the word <tt>void</tt>
must be used for an explicitly empty list. We will discuss this further in
<a href="chapter4.html">Chapter 4</a>.
<p><strong>
You should note that we are using the words <em>definition</em> and
<em>declaration</em> carefully when we refer to external variables in this
section.``Definition'' refers to the place where the variable is created or
assigned storage; ``declaration'' refers to places where the nature of the
variable is stated but no storage is allocated.
</strong>
<p>
By the way, there is a tendency to make everything in sight an <tt>extern</tt>
variable because it appears to simplify communications - argument lists are
short and variables are always there when you want them. But external
variables are always there even when you don't want them. Relying too heavily
on external variables is fraught with peril since it leads to programs whose
data connections are not all obvious - variables can be changed in
unexpected and even inadvertent ways, and the program is hard to modify. The
second version of the longest-line program is inferior to the first, partly
for these reasons, and partly because it destroys the generality of two
useful functions by writing into them the names of the variables they
manipulate.
<p>
At this point we have covered what might be called the conventional core of
C. With this handful of building blocks, it's possible to write useful
programs of considerable size, and it would probably be a good idea if you
paused long enough to do so. These exercises suggest programs of somewhat
greater complexity than the ones earlier in this chapter.
<p>
<strong>*Exercise 1-20.</strong> Write a program <tt>detab</tt> that replaces
tabs in the input with the proper number of blanks to space to the next tab
stop. Assume a fixed set of tab stops, say every <em>n</em> columns. Should
<em>n</em> be a variable or a symbolic parameter?
<p>
<strong>Exercise 1-21.</strong> Write a program <tt>entab</tt> that replaces
strings of blanks by the minimum number of tabs and blanks to achieve the
same spacing. Use the same tab stops as for <tt>detab</tt>. When either a tab
or a single blank would suffice to reach a tab stop, which should be given
preference?
<p>
<strong>Exercise 1-22.</strong> Write a program to  ``fold'' long input lines
into two or more shorter lines after the last non-blank character that occurs
before the <em>n</em>-th column of input. Make sure your program does
something intelligent with very long lines, and if there are no blanks or
tabs before the specified column.
<p>
<strong>*Exercise 1-23.</strong> Write a program to remove all comments from a C program.
Don't forget to handle quoted strings and character constants properly. C
comments don't nest.
<p>
<strong>Exercise 1-24.</strong> Write a program to check a C program for
rudimentary syntax errors like unmatched parentheses, brackets and braces.
Don't forget about quotes, both single and double, escape sequences, and
comments. (This program is hard if you do it in full generality.)
<p>
<hr>
<p align="center">
<a href="intro.html">Back to Introduction</a>&nbsp;--&nbsp;
<a href="index.html">Index</a>&nbsp;--&nbsp;
<a href="chapter2.html">Chapter 2</a>
<p>
<hr>
</body>
</html>
