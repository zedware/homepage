<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter 4 - Functions and Program Structure</title>
    <style type="text/css">
        <!--
        .STYLE1 {
            font-weight: bold
        }

        .STYLE2 {
            color: #FF0000;
            font-weight: bold;
        }

        .STYLE3 {
            color: #FF0000
        }

        .STYLE4 {
            font-weight: bold
        }

        .STYLE5 {
            font-weight: bold
        }
        -->
    </style>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2QMPH4XTZX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-2QMPH4XTZX');
    </script>
</head>

<body>
    <hr>
    <p align="center">
        <a href="chapter3.html">Back to Chapter 3</a>&nbsp;--&nbsp;
        <a href="index.html">Index</a>&nbsp;--&nbsp;
        <a href="chapter5.html">Chapter 5</a>
    <p>
        <hr>

    <h1>Chapter 4 - Functions and Program Structure</h1>
    <strong>Functions break large computing tasks into smaller ones, and enable people to
        build on what others have done instead of starting over from scratch.
        Appropriate functions hide details of operation from parts of the program that
        don't need to know about them, thus clarifying the whole, and easing the pain
        of making changes.</strong>
    <p>
        C has been designed to make functions efficient and easy to use; C programs
        generally consist of many small functions rather than a few big ones. A program
        may reside in one or more source files. Source files may be compiled separately
        and loaded together, along with previously compiled functions from libraries.
        We will not go into that process here, however, since the details vary from
        system to system.
        <!-- wlzhang --> <b> So use functions intensively, just as
            methods in Java and member functions in C++.</b>
    <p>
        <b>Function declaration and definition</b> is the area where the ANSI standard has
        made the most changes to C. As we saw first in <a href="chapter1.html">Chapter 1</a>, it is
        now possible to declare the type of arguments when a function is declared. The
        syntax of function declaration also changes, so that declarations and
        definitions match. This makes it possible for a compiler to detect many more
        errors than it could before. Furthermore, when arguments are properly declared,
        appropriate type coercions are performed automatically.
    <p>
        The standard clarifies the <b>rules on the scope of names</b>; in particular, it
        requires that there be only one definition of each external object.
        Initialization is more general: automatic arrays and structures may now be
        initialized.
    <p>
        The <b>C preprocessor</b> has also been enhanced. New preprocessor facilities include
        a more complete set of conditional compilation directives, a way to create
        quoted strings from macro arguments, and better control over the macro
        expansion process.
    <h2><a name="s4.1">4.1 Basics of Functions</a></h2>
    To begin with, let us design and write a program to print each line of its
    input that contains a particular ``pattern'' or string of characters. (This is
    a special case of the UNIX program <b><tt>grep</tt></b>.) For example, searching for the
    pattern of letters ``<tt>ould</tt>'' in the set of lines
    <pre>
   Ah Love! could you and I with Fate conspire
   To grasp this sorry Scheme of Things entire,
   Would not we shatter it to bits -- and then
   Re-mould it nearer to the Heart's Desire!
</pre>
    will produce the output
    <pre>
   Ah Love! could you and I with Fate conspire
   Would not we shatter it to bits -- and then
   Re-mould it nearer to the Heart's Desire!
</pre>
    <a href="http://article.hongxiu.com/a/2005-11-24/974377.shtml">Chinese edition</a>
    <pre>The job falls neatly into three pieces:
</pre>
    <pre>
while (<em>there's another line</em>)
    if (<em>the line contains the pattern</em>)
        <em>print it</em>
</pre>
    Although it's certainly possible to put the code for all of this in <tt>main</tt>,
    a better way is to use the structure to advantage by making each part a
    separate function. Three small pieces are better to deal with than one big
    one, because irrelevant details can be buried in the functions, and the
    chance of unwanted interactions is minimized. And the pieces may even be
    useful in other programs.
    <p>
        ``While there's another line'' is <tt>getline</tt>, a function that we wrote in
        <a href="chapter1.html">Chapter 1</a>, and ``print it'' is <tt>printf</tt>, which someone has
        already provided for us. This means we need only write a routine to decide
        whether the line contains an occurrence of the pattern.
    <p>
        We can solve that problem by writing a function <tt>strindex(s,t)</tt> that
        returns the position or index in the string <tt>s</tt> where the string <tt>t</tt>
        begins, or <tt>-1</tt> if <tt>s</tt> does not contain <tt>t</tt>. Because C arrays
        begin at position zero, indexes will be zero or positive, and so a negative
        value like <tt>-1</tt> is convenient for <b>signaling failure</b>. When we later need
        more sophisticated pattern matching, we only have to replace <tt>strindex</tt>;
        the rest of the code can remain the same. (The standard library provides a
        function <tt>strstr</tt> that is similar to <tt>strindex</tt>, except that it
        returns a pointer instead of an index.)
    <p>
        Given this much design, filling in the details of the program is
        straightforward. Here is the whole thing, so you can see how the pieces fit
        together. For now, the pattern to be searched for is a literal string, which is
        not the most general of mechanisms. We will return shortly to a discussion
        of how to initialize character arrays, and in <a href="chapter5.html">Chapter 5</a>
        will show how to make the pattern a parameter that is set when the program is run.
        There is also a slightly different version of <tt>getline</tt>; you might find it
        instructive to compare it to the one in <a href="chapter1.html">Chapter 1</a>.
    <pre>
   #include &lt;stdio.h&gt;
   
   #define MAXLINE 1000 /* maximum input line length */

  <strong> static int getline(char line[], int max);
   static int strindex(const char source[], const char searchfor[]);</strong>

   const char Pattern[] = "ould";   /* pattern to search for */

   /* find all lines matching pattern */
   int main(void)
   {
       char line[MAXLINE];
       int  found = 0;

       while (getline(line, MAXLINE) > 0)
       {
           if (strindex(line, Pattern) &gt;= 0)
           {
               printf("%s", line);
               found++;
           }
       }
      
       return found;
   }

<strong>   /* getline:  get line into s, return length */
   static int getline(char s[], int lim)</strong>
   {
       int c;
       int i = 0;

       while (--lim > 0 && (c = getchar()) != EOF && c != '\n')
       {
           s[i++] = c;
       }

       if (c == '\n')
       {
           s[i++] = c;
       }
       
       s[i] = '\0';
       
       return i;
   }

   <strong>/* strindex:  return index of t in s, -1 if none */
   static int strindex(const char s[], const char t[])</strong>
   {
       int i, j, k;

       for (i = 0; s[i] != '\0'; i++)
       {
           for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++)
           {
               ;
           }
           
           if (k > 0 && t[k] == '\0')
           {
               return i;
           }
       }
       
       return -1;
   }
</pre>
    Each function definition has the form
    <pre>
<em>return-type function-name</em>(<em>argument declarations</em>)
{
    <em>declarations and statements</em>
}
</pre>
    Various parts may be absent; a minimal function is
    <pre>
   dummy() {}
</pre>
    which does nothing and returns nothing. A do-nothing function like this is
    sometimes useful as a <b>place holder</b> during program development. If the return
    type is omitted, <tt>int</tt> is assumed.
    <p>
        A program is just a set of definitions of variables and functions.
        Communication between the functions is by arguments and values returned by
        the functions, and through external variables. The functions can occur in
        any order in the source file, and the source program can be split into
        multiple files, so long as no function is split.
    <p>
        The <tt>return</tt> statement is the mechanism for returning a value from the
        called function to its caller. Any expression can follow <tt>return</tt>:
    <pre>
   return <em>expression</em>;
</pre>
    The <em>expression</em> will be converted to the return type of the function
    if necessary. Parentheses are often used around the <em>expression</em>, but
    they are optional.
    <p>
        The calling function is free to ignore the returned value. Furthermore, there
        need to be no expression after <tt>return</tt>; in that case, no value is returned
        to the caller. Control also returns to the caller with no value when execution
        ``falls off the end'' of the function by reaching the closing right brace. It
        is not illegal, but probably a sign of trouble, if a function returns a value
        from one place and no value from another. In any case, if a function fails to
        return a value, its ``value'' is certain to be garbage.
    <p>
        The pattern-searching program returns a status from <tt>main</tt>, the number of
        matches found. This value is available for use by the <b>environment</b> that
        called the program.
    <p><strong>
            The mechanics of how to compile and load a C program that resides on multiple
            source files vary from one system to the next. On the UNIX/Linux system, for
            example, the <tt>cc/gcc</tt> command mentioned in <a href="chapter1.html">Chapter 1</a>
            does the job. Suppose that the three functions are stored in three files
            called <tt>main.c</tt>, <tt>getline.c</tt>, and <tt>strindex.c</tt>. Then
            the command
        </strong>
    <pre>
   $ gcc -Wall main.c getline.c strindex.c
</pre>
    compiles the three files, placing the resulting object code in files
    <tt>main.o</tt>, <tt>getline.o</tt>, and
    <tt>strindex.o</tt>, then loads them all into an executable file called
    <tt>a.out</tt>. If there is an error, say in <tt>main.c</tt>, the file can be
    recompiled by itself and the result loaded with the previous object files,
    with the command
    <pre>
   $ gcc -Wall main.c getline.o strindex.o
</pre>
    The <tt>cc/gcc</tt> command uses the ``<tt>.c</tt>'' versus ``<tt>.o</tt>'' naming
    convention to distinguish source files from object files.
    <p>
        <strong>Exercise 4-1.</strong> Write the function <tt>strindex(s,t)</tt> which returns
        the position of the <em>rightmost</em> occurrence of <tt>t</tt> in <tt>s</tt>, or
        <tt>-1</tt> if there is none.
    <h2><a name="s4.2">4.2 Functions Returning Non-integers</a></h2>
    So far our examples of functions have returned either no value (<tt>void</tt>)
    or an <tt>int</tt>. What if a function must return some other type? many
    numerical functions like <tt>sqrt</tt>, <tt>sin</tt>, and <tt>cos</tt> return
    <tt>double</tt>; other specialized functions return other types. To illustrate
    how to deal with this, let us write and use the function <tt>atof(s)</tt>, which
    converts the string <tt>s</tt> to its double-precision floating-point equivalent.
    <tt>atof</tt> if an extension of <tt>atoi</tt>, which we showed versions of
    in <a href="chapter2.html">Chapters 2</a> and <a href="chapter3.html">3</a>.
    It handles an optional sign and decimal point, and the presence or absence of
    either part or fractional part. Our version is <em>not</em> a high-quality
    input conversion routine; that would take more space than we care to use. The
    standard library includes an <tt>atof</tt>; the header <tt>&lt;stdlib.h&gt;</tt>
    declares it.
    <p>
        First, <tt>atof</tt> itself must declare the type of value it returns, since
        it is not <tt>int</tt>. The type name precedes the function name:
    <pre>
   #include &lt;ctype.h&gt;

   /* atof:  convert string s to double */
   double atof(const char s[])
   {
       double val, power;
       int i, sign;

       for (i = 0; isspace(s[i]); i++)  /* skip white space */
           ;

       sign = (s[i] == '-') ? -1 : 1;
       if (s[i] == '+' || s[i] == '-')
           i++;

       for (val = 0.0; isdigit(s[i]); i++)
           val = 10.0 * val + (s[i] - '0');

       if (s[i] == '.')
           i++;

       for (power = 1.0; isdigit(s[i]); i++)
       {
           val = 10.0 * val + (s[i] - '0');
           power *= 10;
       }

       return sign * val / power;
   }
</pre>
    Second, and just as important, the calling routine must know that <tt>atof</tt>
    returns a non-int value. One way to ensure this is to declare <tt>atof</tt>
    explicitly in the calling routine. The declaration is shown in this primitive
    calculator (barely adequate for check-book balancing), which reads one number
    per line, optionally preceded with a sign, and adds them up, printing the
    running sum after each input:
    <pre>
   #include &lt;stdio.h&gt;

   #define MAXLINE 100

   extern double atof(const char []);
   extern int getline(char line[], int max);

   /* rudimentary calculator */
   int main(void)
   {
       double sum;
       char line[MAXLINE];

       sum = 0;
       while (getline(line, MAXLINE) > 0)
           printf("\t%g\n", sum += atof(line));

       return 0;
   }
</pre>
    The declaration
    <pre>
   extern double atof(const char []); 
   double sum;
</pre>
    says that <tt>sum</tt> is a <tt>double</tt> variable, and that <tt>atof</tt> is a
    function that takes one <tt>char[]</tt> argument and returns a <tt>double</tt>.
    <p>
        The function <tt>atof</tt> must be declared and defined consistently. If
        <tt>atof</tt> itself and the call to it in <tt>main</tt> have inconsistent types in the
        same source file, the error will be detected by the compiler. <strong>But if (as is
            more likely) <tt>atof</tt> were compiled separately, the mismatch would not be
            detected, <tt>atof</tt> would return a <tt>double</tt> that <tt>main</tt> would
            treat as an <tt>int</tt>, and meaningless answers would result. </strong>
        <!-- wlzhang -->
        <b>That's why we should #include the appropriate head files or write the prototypes
            correctly.</b>
    <p class="STYLE1">
        Here is an example to illustrate the importance of prototype.</p>
    <pre><strong>$ cat proto.c
#include &lt;stdio.h&gt;

int main(void)
{
    double d;

    d = sqrt(100);
    printf("%f", d);

    return 0;
}</strong></pre>
    <p><strong>
            If we compile it with GCC or Visual C++ and turn on the warning options, the
            compiler can help us detect the mismatch. And if we don't fix the warnings,
            the result may be totally wrong. If we want to dig out what is wrong underneath,
            reading the assembly instructions can help.</strong></p>
    <pre><strong>
$ gcc -Wall proto.c
proto.c: In function `main':
proto.c:7: warning: implicit declaration of function `sqrt'<br>
$ ./a.out
10.000000   /* haha, it's correct. */

C:\> cl /W3 /nologo proto.c
proto.c
proto.c(7) : warning C4013: “sqrt”未定义；假设外部返回 int

C:\> proto
4194943.000000 /* haha: it's incorrect! */

Compile the source file into assembly only.

$ gcc -Wall -S proto.c
proto.c: In function `main':
proto.c:7: warning: implicit declaration of function `sqrt'

$ cat proto.s
        .file   "proto.c"
        .def    ___main;        .scl    2;      .type   32;     .endef
        .section .rdata,"dr"
LC1:
        .ascii "%f\0"
        .align 8
LC0:
        .long   0
        .long   1076101120
                                ; double x = sqrt(100) = 10.0
                                ; x's bytes:  00 00 00 00 00 00 24 40
                                ; corresponding long: 1076101120
                                ; GCC optimized it. 
        .text
.globl _main
        .def    _main;  .scl    2;      .type   32;     .endef
_main:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $40, %esp
        andl    $-16, %esp
        movl    $0, %eax
        addl    $15, %eax
        addl    $15, %eax
        shrl    $4, %eax
        sall    $4, %eax
        movl    %eax, -12(%ebp)
        movl    -12(%ebp), %eax
        call    __alloca
        call    ___main
        fldl    LC0
        fstpl   -8(%ebp)
        fldl    -8(%ebp)
        fstpl   4(%esp)
        movl    $LC1, (%esp)
        call    _printf
        movl    $0, %eax
        leave
        ret
        .def    _printf;        .scl    2;      .type   32;     .endef

C:\> cl /W3 /nologo /c /FAs proto.c
proto.c
proto.c(7) : warning C4013: “sqrt”未定义；假设外部返回 int

C:\> cat proto.asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

    TITLE   proto.c
    .686P
    .XMM
    include listing.inc
    .model  flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA   SEGMENT
$SG2244 DB  '%f', 00H
_DATA   ENDS
PUBLIC  _main
EXTRN   _printf:PROC
EXTRN   _sqrt:PROC
EXTRN   __fltused:DWORD
; Function compile flags: /Odtp
; File proto.c
_TEXT   SEGMENT
tv70 = -12                      ; size = 4
_d$ = -8                        ; size = 8
_main   PROC

; 4    : {

    push    ebp
    mov ebp, esp
    sub esp, 12                 ; 0000000cH

; 5    :    double d;
; 6    : 
; 7    :    d = sqrt(100);

    push    100                 ; 00000064H
    call    _sqrt
    add esp, 4
    mov DWORD PTR tv70[ebp], eax ; !error here. 
    fild    DWORD PTR tv70[ebp]
    fstp    QWORD PTR _d$[ebp]

; 8    :    printf("%f", d);

    sub esp, 8
    fld QWORD PTR _d$[ebp]
    fstp    QWORD PTR [esp]
    push    OFFSET $SG2244
    call    _printf
    add esp, 12                 ; 0000000cH

; 9    : 
; 10   :    return 0;   

    xor eax, eax

; 11   : }

    mov esp, ebp
    pop ebp
    ret 0
_main   ENDP
_TEXT   ENDS
END</strong></pre>
    <p>
        We can read <a href="http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax">
            X86 Assembly/GAS Syntax</a> to learn more about GCC assembly.
    <p>
        In the light of what we have said about how declarations must match
        definitions, this might seem surprising. The reason a mismatch can happen is
        that if there is no function prototype, a function is implicitly declared by
        its first appearance in an expression, such as
    <pre>
   sum += atof(line)
</pre>
    If a name that has not been previously declared occurs in an expression and is
    followed by a left parentheses, it is declared by context to be a function
    name, the function is assumed to return an <tt>int</tt>, and nothing is assumed
    about its arguments. Furthermore, if a function declaration does not include
    arguments, as in
    <pre>
   double atof();
</pre>
    that too is taken to mean that nothing is to be assumed about the arguments
    of <tt>atof</tt>; all parameter checking is turned off. This special meaning
    of the empty argument list is intended to permit older C programs to compile
    with new compilers. But it's a bad idea to use it with new C programs. <span class="STYLE2">
        If the function takes arguments, declare them; if it takes no arguments, use
        <tt>void</tt>.</span>
    <p>
        Given <tt>atof</tt>, properly declared, we could write <tt>atoi</tt> (convert a
        string to <tt>int</tt>) in terms of it:
    <pre>
   extern double atof(const char s[]);

   /* atoi:  convert string s to integer using atof */
   int atoi(const char s[])
   {
       return (int) atof(s);
   }
</pre>
    Notice the structure of the declarations and the return statement. The value
    of the expression in
    <pre>
   return <em>expression</em>;
</pre>
    is converted to the type of the function before the return is taken.
    Therefore, the value of <tt>atof</tt>, a <tt>double</tt>, is converted
    automatically to <tt>int</tt> when it appears in this <tt>return</tt>, since
    the function <tt>atoi</tt> returns an <tt>int</tt>. This operation does
    potentionally discard information, however, so some <b>compilers warn</b> of it.
    The cast states explicitly that the operation is intended, and suppresses any
    warning.
    <p>
        <strong>Exercise 4-2.</strong> Extend <tt>atof</tt> to handle scientific
        notation of the form
    <pre>
   123.45e-6
</pre>
    where a floating-point number may be followed by <tt>e</tt> or <tt>E</tt> and
    an optionally signed exponent.

    <h2><a name="s4.3">4.3 External Variables</a></h2>
    A C program consists of a set of external objects, which are either variables
    or functions. The adjective ``external'' is used in contrast to ``internal'',
    which describes the arguments and variables defined inside functions. External
    variables are defined outside of any function, and are thus potentionally
    available to many functions. Functions themselves are always external, because
    C does not allow functions to be defined inside other functions. By default,
    external variables and functions have the property that all references to them
    by the same name, even from functions compiled separately, are references to
    the same thing. (The standard calls this property <em>external linkage</em>.)
    In this sense, external variables are analogous to Fortran COMMON blocks or
    variables in the outermost block in Pascal. We will see later how to define
    external variables and functions that are visible only within a single source
    file
    <!-- wlzhang -->(use keyword `static`).
    Because external variables are globally accessible, they provide an alternative
    to function arguments and return values for communicating data between
    functions. Any function may access an external variable by referring to it by
    name, if the name has been declared somehow.
    <p>
        If a large number of variables must be shared among functions, external
        variables are more convenient and efficient than long argument lists. As
        pointed out in <a href="chapter1.html">Chapter 1</a>, however, this reasoning
        should be applied with some caution, for it can have a bad effect on
        program structure, and lead to programs with too many data connections
        between functions.
    <p>
        <!-- wlzhang -->
        And these external variables are commonly known as global varibles. As we all
        know now, global variables may cause tight coupling. As a C programmer, we
        cannot avoid them. But there are ways to help using them well.
    <p>
        External variables are also useful because of their greater scope and lifetime.
        Automatic variables are internal to a function; they come into existence when
        the function is entered, and disappear when it is left. External variables, on
        the other hand, are permanent, so they can retain values from one function
        invocation to the next. Thus if two functions must share some data, yet
        neither calls the other, it is often most convenient if the shared data is
        kept in external variables rather than being passed in and out via arguments.
    <p>
        Let us examine this issue with a larger example. <strong>The problem is to write a
            calculator program that provides the operators <tt>+</tt>, <tt>-</tt>, <tt>*</tt>
            and <tt>/</tt>. Because it is easier to implement, the calculator will use
            <span class="STYLE3">reverse Polish notation</span> instead of infix. (Reverse Polish notation
            is used by some pocket calculators, and in languages like Forth and Postscript.)</strong>
    <p>
        In reverse Polish notation, each operator follows its operands; an infix
        expression like
    <pre>
   (1 - 2) * (4 + 5)
</pre>
    is entered as
    <pre>
   1 2 - 4 5 + *
</pre>
    Parentheses are not needed; the notation is unambiguous as long as we know
    how many operands each operator expects.
    <p>
        The implementation is simple. Each operand is pushed onto a stack; when an
        operator arrives, the proper number of operands (two for binary operators)
        is popped, the operator is applied to them, and the result is pushed back
        onto the stack. In the example above, for instance, 1 and 2 are pushed, then
        replaced by their difference, -1. Next, 4 and 5 are pushed and then replaced
        by their sum, 9. The product of -1 and 9, which is -9, replaces them on
        the stack. The value on the top of the stack is popped and printed when the
        end of the input line is encountered.
    <p>
        The structure of the program is thus a loop that performs the proper operation
        on each operator and operand as it appears:
    <pre>
   while (<em>next operator or operand is not end-of-file indicator</em>)
       if (<em>number</em>)
           <em>push it</em>
       else if (<em>operator</em>)
           <em>pop operands</em>
           <em>do operation</em>
           <em>push result</em>
       else if (<em>newline</em>)
           <em>pop and print top of stack</em>
       else
           <em>error</em>
</pre>
    The operation of pushing and popping a stack are trivial, but by the time error
    detection and recovery are added, they are long enough that it is better to
    put each in a separate function than to repeat the code throughout the whole
    program. And there should be a separate function for fetching the next input
    operator or operand.
    <p>
        The main design decision that has not yet been discussed is where the stack is,
        that is, which routines access it directly. One possibility is to keep it in
        <tt>main</tt>, and pass the stack and the current stack position to the routines
        that push and pop it. But <tt>main</tt> doesn't need to know about the variables
        that control the stack; it only does push and pop operations. So we have
        decided to store the stack and its associated information in external variables
        accessible to the <tt>push</tt> and <tt>pop</tt> functions but not to <tt>main</tt>.
    <p>
        Translating this outline into code is easy enough. If for now we think of the
        program as existing in one source file, it will look like this:
    <p>
        &nbsp;&nbsp;&nbsp;&nbsp;<tt>#include</tt><em>s</em><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<tt>#define</tt><em>s</em>
    <p>
        &nbsp;&nbsp;&nbsp;&nbsp;<em>function declarations for</em> <tt>main</tt>
    <p>
        &nbsp;&nbsp;&nbsp;&nbsp;<tt>main() { ... }</tt>
    <p>
        &nbsp;&nbsp;&nbsp;&nbsp;<em>external variables for</em> <tt>push</tt> <em>and</em> <tt>pop</tt>
    <pre>
    void push( double f) { ... }
    double pop(void) { ... }

    int getop(char s[]) { ... }
</pre>
    &nbsp;&nbsp;&nbsp;<em>routines called by</em> <tt>getop</tt>
    <p>
        Later we will discuss how this might be split into two or more source files.
    <p>
        The function <tt>main</tt> is a loop containing a big <tt>switch</tt> on the type of
        operator or operand; this is a more typical use of <tt>switch</tt> than the one
        shown in <a href="chapter3.html#s3.4">Section 3.4</a>.
    <pre>
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;  /* for  atof() */

   #define MAXOP   100  /* max size of operand or operator */
   #define NUMBER  '0'  /* signal that a number was found */

   extern int getop(char []);
   extern void push(double);
   extern double pop(void);

   /* reverse Polish calculator */
   int main(void)
   {
       int type;
       double op2;
       char s[MAXOP];

       while ((type = getop(s)) != EOF) 
       {
           switch (type)
           {
           case NUMBER:
               push(atof(s));
               break;

           case '+':
               push(pop() + pop());
               break;

           case '*':
               push(pop() * pop());
               break;

           case '-':
               op2 = pop();
               push(pop() - op2);
               break;

           case '/':
               op2 = pop();
               if (op2 != 0.0)
                   push(pop() / op2);
               else
                   printf("error: zero divisor\n");
               break;

           case '\n':
               printf("\t%.8g\n", pop());
               break;

           default:
               printf("error: unknown command %s\n", s);
               break;
           }
       }

       return 0;
   }
</pre>
    Because <tt>+</tt> and <tt>*</tt> are commutative operators, the order in which
    the popped operands are combined is irrelevant, but for <tt>-</tt> and <tt>/</tt>
    the left and right operand must be distinguished. In
    <pre>
   push(pop() - pop());   /* WRONG */
</pre>
    <span class="STYLE3">the order in which the two calls of <tt>pop</tt> are evaluated is <b>not defined</b>.</span> To
    guarantee the right order, it is necessary to pop the first value into a
    temporary variable as we did in <tt>main</tt>.
    <pre>
   #define MAXVAL  100  /* maximum depth of val stack */

   int sp = 0;          /* next free stack position */
   double val[MAXVAL];  /* value stack */

   /* push:  push f onto value stack */
   void push(double f)
   {
       if (sp &lt; MAXVAL)
           val[sp++] = f;
       else
           printf("error: stack full, can't push %g\n", f);
   }

   /* pop:  pop and return top value from stack */
   double pop(void)
   {
       if (sp &gt; 0)
           return val[--sp];
       else
       {
           printf("error: stack empty\n");
           return 0.0;
       }
   }
</pre>
    A variable is external if it is defined outside of any function. Thus the
    stack and stack index that must be shared by <tt>push</tt> and <tt>pop</tt>
    are defined outside these functions. But <tt>main</tt> itself does not refer
    to the stack or stack position - the representation can be hidden.
    <p>
        Let us now turn to the implementation of <tt>getop</tt>, the function that
        fetches the next operator or operand. The task is easy. Skip blanks and tabs.
        If the next character is not a digit or a hexadecimal point, return it.
        Otherwise, collect a string of digits (which might include a decimal point),
        and return <tt>NUMBER</tt>, the signal that a number has been collected.
    <pre>
   #include &lt;ctype.h&gt;

   extern int getch(void);
   extern void ungetch(int);

   /* getop:  get next character or numeric operand */
   int getop(char s[])
   {
       int i, c;

       while ((s[0] = c = getch()) == ' ' || c == '\t')
           ;
       s[1] = '\0';

       if (!isdigit(c) && c != '.')
           return c;      /* not a number */

       i = 0;
       if (isdigit(c))    /* collect integer part */
           while (isdigit(s[++i] = c = getch()))
              ;

       if (c == '.')      /* collect fraction part */
           while (isdigit(s[++i] = c = getch()))
              ;
       s[i] = '\0';

       if (c != EOF)
           ungetch(c);

       return NUMBER;
   }
</pre>
    What are <tt>getch</tt> and <tt>ungetch</tt>? It is often the case that a program
    cannot determine that it has read enough input until it has read too much. One
    instance is collecting characters that make up a number: until the first
    non-digit is seen, the number is not complete. But then the program has read
    one character too far, a character that it is not prepared for.
    <p>
        The problem would be solved if it were possible to ``un-read'' the unwanted
        character. Then, every time the program reads one character too many, it could
        push it back on the input, so the rest of the code could behave as if it had
        never been read. Fortunately, it's easy to simulate un-getting a character, by
        writing a pair of cooperating functions. <tt>getch</tt> delivers the next input
        character to be considered; <tt>ungetch</tt> will return them before reading new
        input.
    <p>
        How they work together is simple. <tt>ungetch</tt> puts the pushed-back
        characters into a shared buffer -- a character array. <tt>getch</tt> reads
        from the buffer if there is anything else, and calls <tt>getchar</tt> if the
        buffer is empty. There must also be an index variable that records the
        position of the current character in the buffer.
    <p>
        Since the buffer and the index are shared by <tt>getch</tt> and <tt>ungetch</tt>
        and must retain their values between calls, they must be external to both
        routines. Thus we can write <tt>getch</tt>, <tt>ungetch</tt>, and their shared
        variables as:
    <pre>
   #define BUFSIZE 100

   char buf[BUFSIZE];    /* buffer for ungetch */
   int bufp = 0;         /* next free position in buf */

   int getch(void)  /* get a (possibly pushed-back) character */
   {
       return (bufp &gt; 0) ? buf[--bufp] : getchar();
   }

   void ungetch(int c)   /* push character back on input */
   {
       if (bufp &gt;= BUFSIZE)
           printf("ungetch: too many characters\n");
       else
           buf[bufp++] = c;
   }
</pre>
    The standard library includes a function <tt>ungetch</tt> that provides one
    character of pushback; we will discuss it in <a href="chapter7.html">Chapter 7</a>.
    We have used an array for the pushback, rather than a single character, to
    illustrate a more general approach.
    <p>
        <strong>Exercise 4-3.</strong> Given the basic framework, it's
        straightforward to extend the calculator. Add the modulus (%) operator and
        provisions for negative numbers.
    <p>
        <strong>Exercise 4-4.</strong> Add the commands to print the top elements of
        the stack without popping, to duplicate it, and to swap the top two elements.
        Add a command to clear the stack.
    <p>
        <strong>Exercise 4-5.</strong> Add access to library functions like
        <tt>sin</tt>, <tt>exp</tt>, and <tt>pow</tt>. See </tt>&lt;math.h&gt;</tt> in
        <a href="appb.html#sb.4">Appendix B, Section 4</a>.
    <p>
        <strong>*Exercise 4-6.</strong> Add commands for handling variables. (It's
        easy to provide twenty-six variables with single-letter names.) Add a
        variable for the most recently printed value.
    <p>
        <strong>Exercise 4-7.</strong> Write a routine <tt>ungets(s)</tt> that will
        push back an entire string onto the input. Should <tt>ungets</tt> know about
        <tt>buf</tt> and <tt>bufp</tt>, or should it just use <tt>ungetch</tt>?
    <p>
        <strong>Exercise 4-8.</strong> Suppose that there will never be more than one
        character of pushback. Modify <tt>getch</tt> and <tt>ungetch</tt>
        accordingly.
    <p>
        <strong>Exercise 4-9.</strong> Our <tt>getch</tt> and <tt>ungetch</tt> do not
        handle a pushed-back <tt>EOF</tt> correctly. Decide what their properties
        ought to be if an <tt>EOF</tt> is pushed back, then implement your design.
    <p>
        <strong>Exercise 4-10.</strong> An alternate organization uses
        <tt>getline</tt> to read an entire input line; this makes <tt>getch</tt> and
        <tt>ungetch</tt> unnecessary. Revise the calculator to use this approach.
    <h2><a name="s4.4">4.4 Scope Rules</a></h2>
    The functions and external variables that make up a C program need not all
    be compiled at the same time; the source text of the program may be kept in
    several files, and previously compiled routines may be loaded from libraries.
    Among the questions of interest are
    <ul>
        <li>How are declarations written so that variables are properly declared
            during compilation?
        <li>How are declarations arranged so that all the pieces will be properly
            connected when the program is loaded?
        <li>How are declarations organized so there is only one copy?
        <li>How are external variables initialized?
    </ul>
    Let us discuss these topics by reorganizing the calculator program into
    several files. As a practical matter, the calculator is too small to be worth
    splitting, but it is a fine illustration of the issues that arise in larger
    programs.
    <p>
        The <em>scope</em> of a name is the part of the program within which the name
        can be used. For an automatic variable declared at the beginning of a function,
        the scope is the function in which the name is declared. Local variables of
        the same name in different functions are unrelated. The same is true of the
        parameters of the function, which are in effect local variables.
    <p>
        The scope of an external variable or a function lasts from the point at
        which it is declared to the end of the file being compiled. For example,
        if <tt>main</tt>, <tt>sp</tt>, <tt>val</tt>, <tt>push</tt>, and
        <tt>pop</tt> are defined in one file, in the order shown above, that is,
    <pre>
   main() { ... }

   int sp = 0;
   double val[MAXVAL];

   void push(double f) { ... }

   double pop(void) { ... }
</pre>
    then the variables <tt>sp</tt> and <tt>val</tt> may be used in <tt>push</tt>
    and <tt>pop</tt> simply by naming them; no further declarations are needed.
    But these names are not visible in <tt>main</tt>, nor are <tt>push</tt> and
    <tt>pop</tt> themselves.
    <p>
        On the other hand, if an external variable is to be referred to before it is
        defined, or if it is defined in a different source file from the one where it
        is being used, then an <tt>extern</tt> declaration is <span class="STYLE3"><b>mandatory</b></span>.
    <p>
        It is important to distinguish between the <em>declaration</em> of an external
        variable and its <em>definition</em>. A declaration announces the properties
        of a variable (primarily its type); a definition also causes storage to be
        set aside. If the lines
    <pre>
   int sp;
   double val[MAXVAL];
</pre>
    appear outside of any function, they <em>define</em> the external variables
    <tt>sp</tt> and <tt>val</tt>, cause storage to be set aside, and also
    serve as the declarations for the rest of that source file. On the other hand,
    the lines
    <pre>
   extern int sp;
   extern double val[];
</pre>
    <em>declare</em> for the rest of the source file that <tt>sp</tt> is an <tt>int</tt>
    and that <tt>val</tt> is a <tt>double</tt> array (whose size is determined
    elsewhere), but they do not create the variables or reserve storage for them.
    <p>
        There must be only <em>one definition</em> of an external variable among all the
        files that make up the source program; other files may contain <tt>extern</tt>
        declarations to access it. (There may also be <tt>extern</tt> declarations in
        the file containing the definition.) Array sizes <b>must be</b> specified with
        the definition, but are optional with an <tt>extern</tt> declaration.
    <p>
        Initialization of an external variable goes only with the definition.
    <p>
        Although it is not a likely organization for this program, the functions
        <tt>push</tt> and <tt>pop</tt> could be defined in one file, and the variables
        <tt>val</tt> and <tt>sp</tt> defined and initialized in another. Then these
        definitions and declarations would be necessary to tie them together:
    <p>
        &nbsp;&nbsp;<em>in file1</em>:
    <pre>
      extern int sp;
      extern double val[];

      void push(double f) { ... }
      double pop(void) { ... }
</pre>
    <em>&nbsp;&nbsp;in file2</em>:
    <pre>
      int sp = 0;
      double val[MAXVAL];
</pre>
    Because the <tt>extern</tt> declarations in <em>file1</em> lie ahead of and outside
    the function definitions, they apply to all functions; one set of declarations
    suffices for all of <em>file1</em>. This same organization would also bee needed
    if the definition of <tt>sp</tt> and <tt>val</tt> followed their use in one file.

    <h2><a name="s4.5">4.5 Header Files</a></h2>
    Let is now consider dividing the calculator program into several source
    files, as it might be is each of the components were substantially bigger.
    The <tt>main</tt> function would go in one file, which we will call
    <tt>main.c</tt>; <tt>push</tt>, <tt>pop</tt>, and their variables go into a
    second file, <tt>stack.c</tt>; <tt>getop</tt> goes into a third,
    <tt>getop.c</tt>. Finally, <tt>getch</tt> and <tt>ungetch</tt> go into a
    fourth file, <tt>getch.c</tt>; we separate them from the others because they
    would come from a separately-compiled library in a realistic program.
    <p>
        There is one more thing to worry about - the definitions and declarations
        shared among files. As much as possible, we want to centralize this, so that
        there is <b>only one copy</b> to get and keep right as the program evolves.
        Accordingly, we will place this common material in a <em>header file</em>,
        <tt>calc.h</tt>, which will be included as necessary. (The <tt>#include</tt>
        line is described in <a href="#s4.11">Section 4.11</a>.) The resulting program
        then looks like this:
    <p>
        <img src="pic41.gif">
    <p>
        There is a tradeoff between the desire that each file have access only to the
        information it needs for its job and the practical reality that it is harder
        to maintain more header files. <b>Up to some moderate program size, it is
            probably best to have one header file that contains everything that is to be
            shared between any two parts of the program; that is the decision we made
            here. For a much larger program, more organization and more headers would be
            needed.</b>
    <h2><a name="s4.6">4.6 Static Variables</a></h2>
    The variables <tt>sp</tt> and <tt>val</tt> in <tt>stack.c</tt>, and <tt>buf</tt> and
    <tt>bufp</tt> in <tt>getch.c</tt>, are for the private use of the functions in their
    respective source files, and are not meant to be accessed by anything else. The
    <tt>static</tt> declaration, applied to an external variable or function, limits
    the scope of that object to the rest of the source file being compiled.
    External <tt>static</tt> thus provides a way to hide names like <tt>buf</tt> and
    <tt>bufp</tt> in the <tt>getch-ungetch</tt> combination, which must be external so they
    can be shared, yet which should not be visible to users of <tt>getch</tt> and
    <tt>ungetch</tt>.
    <p>
        Static storage is specified by prefixing the normal declaration with the word
        <tt>static</tt>. If the two routines and the two variables are compiled in one
        file, as in
    <pre>
   static char buf[BUFSIZE];  /* buffer for ungetch */
   static int bufp = 0;       /* next free position in buf */

   int getch(void) { ... }
   void ungetch(int c) { ... }
</pre>
    then no other routine will be able to access <tt>buf</tt> and <tt>bufp</tt>, and
    those names will not conflict with the same names in other files of the same
    program. In the same way, the variables that <tt>push</tt> and <tt>pop</tt> use for
    stack manipulation can be hidden, by declaring <tt>sp</tt> and <tt>val</tt> to be
    <tt>static</tt>.
    <p>
        The external <tt>static</tt> declaration is most often used for variables,
        but it can be applied to functions as well. Normally, function names are
        global, visible to any part of the entire program. If a function is declared
        <tt>static</tt>, however, its name is invisible outside of the file in which
        it is declared.
    <p>
        The <tt>static</tt> declaration can also be applied to internal variables.
        Internal <tt>static</tt> variables are local to a particular function just as
        automatic variables are, but unlike automatics, they remain in existence
        rather than coming and going each time the function is activated. This means
        that internal <tt>static</tt> variables provide private, permanent storage
        within a single function.
    <p>
        So there are three places the `static` keyword can be placed. For private variables,
        for private functions, and for internal variables.
    <p>
        <strong>Exercise 4-11.</strong> Modify <tt>getop</tt> so that it doesn't need to
        use <tt>ungetch</tt>. Hint: use an internal <tt>static</tt> variable.
    <h2><a name="s4.7">4.7 Register Variables</a></h2>
    A <tt>register</tt> declaration advises the compiler that the variable in
    question will be heavily used. The idea is that <tt>register</tt> variables are
    to be placed in machine registers, which may result in smaller and faster
    programs. But compilers are free to ignore the advice.
    <p>
        The <tt>register</tt> declaration looks like
    <pre>
   register int  x;
   register char c;
</pre>
    and so on. The <tt>register</tt> declaration can only be applied to automatic
    variables and to the formal parameters of a function. In this later case, it
    looks like
    <pre>
   f(register unsigned m, register long n)
   {
       register int i;
       ...
   }
</pre>
    In practice, there are restrictions on register variables, reflecting the
    realities of underlying hardware. Only a few variables in each function may
    be kept in registers, and only certain types are allowed. Excess register
    declarations are harmless, however, since the word <tt>register</tt> is
    ignored for excess or disallowed declarations. And it is not possible to take
    the address of a register variable (a topic covered in <a href="chapter5.html">Chapter 5</a>), regardless of whether
    the variable is
    actually placed in a register. The specific restrictions on number and types
    of register variables vary from machine to machine.
    <p>
        <!-- wlzhang -->
        As for mordern compilers and large scale programs, we seldom use register
        variables now.
    <h2><a name="s4.8">4.8 Block Structure</a></h2>
    C is not a block-structured language in the sense of Pascal or similar
    languages, because functions <b>may not</b> be defined within other functions.
    On the other hand, variables can be defined in a block-structured fashion within
    a function. Declarations of variables (including initializations) may follow
    the left brace that introduces <em>any</em> compound statement, not just the
    one that begins a function. Variables declared in this way hide any
    identically named variables in outer blocks, and remain in existence until
    the matching right brace. For example, in
    <pre>
   if (n > 0) {
       int i;  /* declare a new i */

       for (i = 0; i &lt; n; i++)
           ...
   }
</pre>
    the scope of the variable <tt>i</tt> is the ``true'' branch of the
    <tt>if</tt>; this <tt>i</tt> is unrelated to any <tt>i</tt> outside the
    block. An automatic variable declared and initialized in a block is
    initialized <span class="STYLE3"><b>each time</b></span> the block is entered.
    <p>
        Automatic variables, including formal parameters, also hide external variables
        and functions of the same name. Given the declarations
    <pre>
   int x;
   int y;

   f(double x)
   {
       double y;
   }
</pre>
    then within the function <tt>f</tt>, occurrences of <tt>x</tt> refer to the
    parameter, which is a <tt>double</tt>; outside <tt>f</tt>, they refer to the
    external <tt>int</tt>. The same is true of the variable <tt>y</tt>.
    <p>
        As a matter of style, it's best to avoid variable names that conceal/hide names
        in an outer scope; the potential for confusion and error is too great.
    <h2><a name="s4.9">4.9 Initialization</a></h2>
    Initialization has been mentioned in passing many times so far, but always
    peripherally to some other topic. This section summarizes some of the rules,
    now that we have discussed the various storage classes.
    <p class="STYLE3">
        <b>
            In the absence of explicit initialization, external and static variables are
            guaranteed to be initialized to zero; automatic and register variables have
            undefined (i.e., garbage) initial values.</b>
    <p>
        Scalar variables may be initialized when they are defined, by following the
        name with an equals sign and an expression:
    <pre>
   int x = 1;
   char squota = '\'';
   long day = 1000L * 60L * 60L * 24L; /* milliseconds/day */
</pre>
    For external and static variables, the initializer must be a constant
    expression; the initialization is done once, conceptionally before the program
    begins execution. For automatic and register variables, the initializer is not
    restricted to being a constant: it may be any expression involving previously
    defined values, even function calls. For example, the initialization of the
    binary search program in <a href="chapter3.html#s3.3">Section 3.3</a> could
    be written as
    <pre>
   int binsearch(int x, int v[], int n)
   {
       int low = 0;
       int high = n - 1;
       int mid;
       ...
   }
</pre>
    instead of
    <pre>
       int low, high, mid;

       low = 0;
       high = n - 1;
</pre>
    In effect, initialization of automatic variables are just shorthand for
    assignment statements. Which form to prefer is largely a matter of taste.
    We have generally used explicit assignments, because initializers in
    declarations are harder to see and further away from the point of use.
    <p>
        An array may be initialized by following its declaration with a list of
        initializers enclosed in braces and separated by commas. For example, to
        initialize an array <tt>days</tt> with the number of days in each month:
    <pre>
   int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
</pre>
    When the size of the array is omitted, the compiler will compute the length by
    counting the initializers, of which there are 12 in this case.
    <!-- wlzhang -->
    And it is one of the best pratices of practical programmers.
    <p>
        If there are fewer initializers for an array than the specified size, the
        others will be zero for external, static and automatic variables. It is an
        error to have too many initializers. There is no way to specify repetition
        of an initializer, nor to initialize an element in the middle of an array
        without supplying all the preceding values as well.
    <p>
        Character arrays are a special case of initialization; a string may be used
        instead of the braces and commas notation:
    <pre>
   char pattern = "ould";
</pre>
    is a shorthand for the longer but equivalent
    <pre>
   char pattern[] = { 'o', 'u', 'l', 'd', '\0' };
</pre>
    In this case, the array size is five (four characters plus the terminating
    <tt>'\0'</tt>).
    <!-- wlzhang, const char -->
    <h2><a name="s4.10">4.10 Recursion</a></h2>
    C functions may be used recursively; that is, a function may call itself
    either directly or indirectly. Consider printing a number as a character
    string. As we mentioned before, the digits are generated in the wrong order:
    low-order digits are available before high-order digits, but they have to be
    printed the other way around.
    <p>
        There are two solutions to this problem. On is to store the digits in an
        array as they are generated, then print them in the reverse order, as we did
        with <tt>itoa</tt> in <a href="chapter3.html#s3.6">section 3.6</a>. The
        alternative is a recursive solution, in which <tt>printd</tt> first calls
        itself to cope with any leading digits, then prints the trailing digit.
        Again, this version can fail on the largest negative number.
    <pre>
   #include &lt;stdio.h&gt;

   /* printd:  print n in decimal */
   void printd(int n)
   {
       if (n &lt; 0) 
       {
           putchar('-');
           n = -n;
       }

       if (n / 10)
           printd(n / 10);

       putchar(n % 10 + '0');
   }
</pre>
    When a function calls itself recursively, each invocation gets a fresh set of
    all the automatic variables, independent of the previous set. This in <tt>
        printd(123)</tt> the first <tt>printd</tt> receives the argument <tt>n = 123</tt>.
    It passes <tt>12</tt> to a second <tt>printd</tt>, which in turn passes
    <tt>1</tt> to a third. The third-level <tt>printd</tt> prints <tt>1</tt>, then
    returns to the second level. That <tt>printd</tt> prints <tt>2</tt>, then
    returns to the first level. That one prints <tt>3</tt> and terminates.
    <p>
        Another good example of recursion is quicksort, a sorting algorithm developed
        by C.A.R. Hoare in 1962. Given an array, one element is chosen and the others
        partitioned in two subsets - those less than the partition element and those
        greater than or equal to it. The same process is then applied recursively to
        the two subsets. When a subset has fewer than two elements, it doesn't need
        any sorting; this stops the recursion.
    <p>
        Our version of quicksort is not the fastest possible, but it's one of the
        simplest. We use the middle element of each subarray for partitioning.
    <pre>
   /* qsort:  sort v[left]...v[right] into increasing order */
   void qsort(int v[], int left, int right)
   {
       int i, last;
       void swap(int v[], int i, int j);

       if (left &gt;= right) /* do nothing if array contains */
           return;           /* fewer than two elements */
       swap(v, left, (left + right)/2); /* move partition elem */
       last = left;                     /* to v[0] */
       for (i = left + 1; i &lt;= right; i++)  /* partition */
       {
           if (v[i] &lt; v[left])
               swap(v, ++last, i);
       }
       swap(v, left, last);            /* restore partition  elem */

       qsort(v, left, last - 1);
       qsort(v, last+1, right);
   }
</pre>
    We moved the swapping operation into a separate function <tt>swap</tt> because it
    occurs three times in <tt>qsort</tt>.
    <pre>
   /* swap:  interchange v[i] and v[j] */
   void swap(int v[], int i, int j)
   {
       int temp;

       temp = v[i];
       v[i] = v[j];
       v[j] = temp;
   }
</pre>
    The standard library includes a version of <tt>qsort</tt> that can sort objects of
    any type.
    <p>
        Recursion may provide no saving in storage, since somewhere a stack of the
        values being processed must be maintained. Nor will it be faster. But
        recursive code is more compact, and often much easier to write and understand
        than the non-recursive equivalent. Recursion is especially convenient for
        recursively defined data structures like trees, we will see a nice example
        in <a href="chapter6.html#s6.6">Section 6.6</a>.
    <p>
        <strong>Exercise 4-12.</strong> Adapt the ideas of <tt>printd</tt> to write a recursive
        version of <tt>itoa</tt>; that is, convert an integer into a string by calling
        a recursive routine.
    <p>
        <strong>*Exercise 4-13.</strong> Write a recursive version of the function <tt>reverse(s)</tt>,
        which reverses the string <tt>s</tt> in place.
    <h2><a name="s4.11">4.11 The C Preprocessor</a></h2>
    C provides certain language facilities by means of a preprocessor, which is
    conceptionally a separate first step in compilation. The two most frequently
    used features are <tt>#include</tt>, to include the contents of a file during
    compilation, and <tt>#define</tt>, to replace a token by an arbitrary sequence of
    characters. Other features described in this section include conditional
    compilation and macros with arguments.

    <h3><a name="s4.11.1">4.11.1 File Inclusion</a></h3>
    File inclusion makes it easy to handle collections of <tt>#define</tt>s and
    declarations (among other things). Any source line of the form
    <pre>
   #include "<em>filename</em>"
</pre>
    or
    <pre>
   #include &lt;<em>filename</em>&gt;
</pre>
    is replaced by the contents of the file <em>filename</em>. If the <em>filename</em>
    is quoted, searching for the file typically begins where the source program
    was found; if it is not found there, or if the name is enclosed in &lt; and
    &gt;, searching follows an implementation-defined rule to find the file. An
    included file may itself contain <tt>#include</tt> lines.
    <p>
        There are often several <tt>#include</tt> lines at the beginning of a source
        file, to include common <tt>#define</tt> statements and <tt>extern</tt> declarations,
        or to access the function prototype declarations for library functions from
        headers like <tt>&lt;stdio.h&gt;</tt>. (Strictly speaking, these need not be files;
        the details of how headers are accessed are implementation-dependent.)
    <p>
        <tt>#include</tt> is the preferred way to tie the declarations together for a
        large program. It guarantees that all the source files will be supplied with
        the same definitions and variable declarations, and thus eliminates a
        particularly nasty kind of bug. Naturally, when an included file is changed,
        all files that depend on it must be recompiled.
    <h3><a name="s4.11.2">4.11.2 Macro Substitution</a></h3>
    A definition has the form
    <pre>
   #define <em>name replacement text</em>
</pre>
    It calls for a macro substitution of the simplest kind - subsequent
    occurrences of the token <tt>name</tt> will be replaced by the
    <em>replacement text</em>. The name in a <tt>#define</tt> has the same form
    as a variable name; the replacement text is arbitrary. Normally the
    replacement text is the rest of the line, but a long definition may be
    continued onto several lines by placing a <b><tt>\</tt></b> at the end of each line
    to be continued. The scope of a name defined with <tt>#define</tt> is from
    its point of definition to the end of the source file being compiled. A
    definition may use previous definitions. Substitutions are made only for
    tokens, and do not take place within quoted strings. For example, if
    <tt>YES</tt> is a defined name, there would be no substitution in
    <tt>printf("YES")</tt> or in <tt>YESMAN</tt>.
    <!-- wlzhang -->
    <p class="STYLE4">
        Here are some samples of macros. Please figure out:
    <p><strong> 1) Why sizeof is ok in lengthof(x). and
        </strong>
    <p><strong>2) do { } while(0) is necessary in in swap(a, b).
        </strong>
    <pre><strong>
    /* Return the maximum value of x and y. */ 
    #define Max(x, y)       ((x) > (y) ? : (x) : (y))
    
    /* Caculate the length of an array x[]. */
    #define lengthof(x)     (sizeof(x) / sizeof(x[0])
    
    /* Swap two integers. */
    #define swap(a, b)      do { \
                                int _t; _t = a; a = b; b = _t;  \
                            } while (0)
</strong><br>Any name may be defined with any replacement text. For example<br><strong>
   #define  forever  for (;;)    /* infinite loop */</strong></pre>
    defines a new word, <tt>forever</tt>, for an infinite loop.
    <p>
        It is also possible to define macros with arguments, so the replacement text
        can be different for different calls of the macro. As an example, define a
        macro called <tt>max</tt>:
    <pre><strong>   #define  max(x, y)  ((x) &gt; (y) ? (x) : (y))</strong></pre>
    Although it looks like a function call, a use of <tt>max</tt> expands into
    in-line code. Each occurrence of a formal parameter (here <tt>x</tt> or <tt>y</tt>)
    will be replaced by the corresponding actual argument. Thus the line
    <pre>
   x = max(p + q, r + s);
</pre>
    will be replaced by the line
    <pre>
   x = ((p + q) > (r + s) ? (p + q) : (r + s));
</pre>
    So long as the arguments are treated consistently, this macro will serve for
    any data type; there is no need for different kinds of <tt>max</tt> for different
    data types, as there would be with functions.
    <p class="STYLE3">
        If you examine the expansion of <tt>max</tt>, you will notice <b>some pitfalls. The
            expressions are evaluated twice; this is bad if they involve side effects like
            increment operators or input and output. For instance</b>
    <pre>
   max(i++, j++)  /* WRONG */
</pre>
    will increment the larger twice. Some care also has to be taken with
    <b>parentheses</b> to make sure the order of evaluation is preserved; consider what
    happens when the macro
    <pre>
   #define square(x)  x * x  /* WRONG */
</pre>
    is invoked as <tt>square(z + 1)</tt>.
    <p>
        Nonetheless, macros are valuable. One practical example comes from
        <tt>&lt;stdio.h&gt</tt>, in which <tt>getchar</tt> and <tt>putchar</tt> are
        often defined as macros to avoid the run-time overhead of a function call per
        character processed. The functions in <tt>&lt;ctype.h&gt;</tt> are also usually
        implemented as macros.
        <!-- wlzhang -->
    <p>
        <b>We should remember some facts:</b>
    <ul>
        <li><strong>Avoid using macros in C++.</strong></li>
        <li><strong>We maynot avoid using macros in C programming.</strong></li>
        <li><strong>Macros are better stuff, if we use it correctly and carefully.</strong></li>
        <li><strong>Remember to use parenthesis.</strong></li>
        <li><strong>Try to avoid side effect of macro's parameters.</strong></li>
    </ul>
    <p>
        Names may be undefined with <tt>#undef</tt>, usually to ensure that a routine is
        really <b>a function, not a macro</b>:
    <pre>
   #undef getchar

   int getchar(void) { ... }
</pre>
    Formal parameters are not replaced within quoted strings. If, however, a
    parameter name is preceded by a <tt>#</tt> in the replacement text, the
    combination will be expanded into a quoted string with the parameter
    replaced by the actual argument. This can be combined with string concatenation
    to make, for example, a debugging print macro:
    <pre>
   #define  dprint(expr)   printf(#expr " = %g\n", expr)
</pre>
    When this is invoked, as in
    <pre>
   dprint(x/y)
</pre>
    the macro is expanded into
    <pre>
   printf("x/y" " = &g\n", x/y);
</pre>
    and the strings are concatenated, so the effect is
    <pre>
   printf("x/y = &g\n", x/y);
</pre>
    Within the actual argument, each <tt>"</tt> is replaced by <tt>\"</tt> and each
    <tt>\</tt> by <tt>\\</tt>, so the result is a legal string constant.
    <p>
        The preprocessor operator <tt>##</tt> provides a way to concatenate actual
        arguments during macro expansion. If a parameter in the replacement text is
        adjacent to a <tt>##</tt>, the parameter is replaced by the actual argument, the
        <tt>##</tt> and surrounding white space are removed, and the result is
        re-scanned. For example, the macro <tt>paste</tt> concatenates its two arguments:
    <pre>
   #define  paste(front, back)  front ## back
</pre>
    so <tt>paste(name, 1)</tt> creates the token <tt>name1</tt>.
    <p>
        The rules for nested uses of <tt>##</tt> are arcane; further details may be
        found in <a href="appa.html">Appendix A</a>.
    <p>
        <strong>*Exercise 4-14.</strong> Define a macro <tt>swap(t,x,y)</tt> that
        interchanges two arguments of type <tt>t</tt>. (Block structure will help.)
    <h3><a name="s4.11.3">4.11.3 Conditional Inclusion</a></h3>
    It is possible to control preprocessing itself with conditional statements
    that are evaluated during preprocessing. This provides a way to include code
    selectively, depending on the value of conditions evaluated during compilation.
    <p>
        The <tt>#if</tt> line evaluates a constant integer expression (which may not
        include <tt>sizeof</tt>, casts, or <tt>enum</tt> constants). If the expression is
        non-zero, subsequent lines until an <tt>#endif</tt> or <tt>#elif</tt> or
        <tt>#else</tt> are included. (The preprocessor statement <tt>#elif</tt> is like
        <tt>else-if</tt>.) The expression <tt>defined</tt>(<em>name</em>) in a
        <tt>#if</tt> is 1 if the <em>name</em> has been defined, and 0 otherwise.
    <p>
        For example, to make sure that the contents of a file <tt>hdr.h</tt> are included
        only once, the contents of the file are surrounded with a conditional like
        this:
    <pre>
   #if !defined(HDR)
   #define HDR

   /* contents of hdr.h go here */

   #endif
</pre>
    The first inclusion of <tt>hdr.h</tt> defines the name <tt>HDR</tt>; subsequent
    inclusions will find the name defined and skip down to the <tt>#endif</tt>. A
    similar style can be used to avoid including files multiple times. If this
    style is used consistently, then each header can itself include any other
    headers on which it depends, without the user of the header having to deal with
    the interdependence.
    <p>
        This sequence tests the name <tt>SYSTEM</tt> to decide which version of a header
        to include:
    <pre>
   #if SYSTEM == SYSV
       #define HDR "sysv.h"
   #elif SYSTEM == BSD
       #define HDR "bsd.h"
   #elif SYSTEM == MSDOS
       #define HDR "msdos.h"
   #else
       #define HDR "default.h"
   #endif
   #include HDR
</pre>
    The <tt>#ifdef</tt> and <tt>#ifndef</tt> lines are specialized forms that test
    whether a name is defined. The first example of <tt>#if</tt> above could have
    been written
    <pre>
   #ifndef HDR
   #define HDR

   /* contents of hdr.h go here */

   #endif
</pre>
    <h3><a name="s4.11.4">4.11.4 Compilers</a></h3>
    <p class="STYLE5">
        Comiplers should provide some options to let us generate and see expanded sources.
        Here are two examples for GCC and Visual C++.
    <pre><strong>$ gcc -Wall -E hello.c
C:\> cl /W3 /E proto.c </strong></pre>
    <p><strong>
            We will learn more about the command line options of different compilers in our career.
            Generally, we can rely on these simple ways:
        </strong>
    <ul>
        <li><strong>`cmd /?` or `cmd -h` for Windows applications.</strong></li>
        <li><strong>`cmd -h` or `cmd --help` for Unix/Linux/Java applications.</strong></li>
        <li><strong>Read compiler's manual or online documents.</strong></li>
    </ul>
    <hr>
    <p align="center">
        <a href="chapter3.html">Back to Chapter 3</a>&nbsp;--&nbsp;
        <a href="index.html">Index</a>&nbsp;--&nbsp;
        <a href="chapter5.html">Chapter 5</a>
    <p>
        <hr>
</body>

</html>
